// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proio/model/lcio/lcio.proto

/*
	Package lcio is a generated protocol buffer package.

	It is generated from these files:
		proio/model/lcio/lcio.proto

	It has these top-level messages:
		ParticleID
		MCParticle
		MCParticleCollection
		SimTrackerHit
		SimTrackerHitCollection
		TrackerRawData
		TrackerRawDataCollection
		TrackerData
		TrackerDataCollection
		TrackerHit
		TrackerHitCollection
		TrackerPulse
		TrackerPulseCollection
		TrackerHitPlane
		TrackerHitPlaneCollection
		TrackerHitZCylinder
		TrackerHitZCylinderCollection
		Track
		TrackCollection
		SimCalorimeterHit
		SimCalorimeterHitCollection
		RawCalorimeterHit
		RawCalorimeterHitCollection
		CalorimeterHit
		CalorimeterHitCollection
		Cluster
		ClusterCollection
		RecParticle
		RecParticleCollection
		Vertex
		VertexCollection
		Relation
		RelationCollection
*/
package lcio

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import proio_model "github.com/decibelcooper/proio/go-proio/model"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ParticleID struct {
	Likelihood float32   `protobuf:"fixed32,1,opt,name=likelihood,proto3" json:"likelihood,omitempty"`
	Type       int32     `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	PDG        int32     `protobuf:"varint,3,opt,name=PDG,proto3" json:"PDG,omitempty"`
	AlgType    int32     `protobuf:"varint,4,opt,name=algType,proto3" json:"algType,omitempty"`
	Params     []float32 `protobuf:"fixed32,5,rep,packed,name=params" json:"params,omitempty"`
}

func (m *ParticleID) Reset()                    { *m = ParticleID{} }
func (m *ParticleID) String() string            { return proto.CompactTextString(m) }
func (*ParticleID) ProtoMessage()               {}
func (*ParticleID) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{0} }

func (m *ParticleID) GetLikelihood() float32 {
	if m != nil {
		return m.Likelihood
	}
	return 0
}

func (m *ParticleID) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ParticleID) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *ParticleID) GetAlgType() int32 {
	if m != nil {
		return m.AlgType
	}
	return 0
}

func (m *ParticleID) GetParams() []float32 {
	if m != nil {
		return m.Params
	}
	return nil
}

type MCParticle struct {
	Id        uint32                   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Parents   []*proio_model.Reference `protobuf:"bytes,2,rep,name=parents" json:"parents,omitempty"`
	Children  []*proio_model.Reference `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	PDG       int32                    `protobuf:"varint,4,opt,name=PDG,proto3" json:"PDG,omitempty"`
	Vertex    []float64                `protobuf:"fixed64,5,rep,packed,name=vertex" json:"vertex,omitempty"`
	Time      float32                  `protobuf:"fixed32,6,opt,name=time,proto3" json:"time,omitempty"`
	P         []float64                `protobuf:"fixed64,7,rep,packed,name=p" json:"p,omitempty"`
	Mass      float64                  `protobuf:"fixed64,8,opt,name=mass,proto3" json:"mass,omitempty"`
	Charge    float32                  `protobuf:"fixed32,9,opt,name=charge,proto3" json:"charge,omitempty"`
	PEndPoint []float64                `protobuf:"fixed64,10,rep,packed,name=PEndPoint" json:"PEndPoint,omitempty"`
	Spin      []float32                `protobuf:"fixed32,11,rep,packed,name=spin" json:"spin,omitempty"`
	ColorFlow []int32                  `protobuf:"varint,12,rep,packed,name=colorFlow" json:"colorFlow,omitempty"`
	GenStatus int32                    `protobuf:"varint,13,opt,name=genStatus,proto3" json:"genStatus,omitempty"`
	SimStatus uint32                   `protobuf:"varint,14,opt,name=simStatus,proto3" json:"simStatus,omitempty"`
}

func (m *MCParticle) Reset()                    { *m = MCParticle{} }
func (m *MCParticle) String() string            { return proto.CompactTextString(m) }
func (*MCParticle) ProtoMessage()               {}
func (*MCParticle) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{1} }

func (m *MCParticle) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MCParticle) GetParents() []*proio_model.Reference {
	if m != nil {
		return m.Parents
	}
	return nil
}

func (m *MCParticle) GetChildren() []*proio_model.Reference {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *MCParticle) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *MCParticle) GetVertex() []float64 {
	if m != nil {
		return m.Vertex
	}
	return nil
}

func (m *MCParticle) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *MCParticle) GetP() []float64 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *MCParticle) GetMass() float64 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *MCParticle) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *MCParticle) GetPEndPoint() []float64 {
	if m != nil {
		return m.PEndPoint
	}
	return nil
}

func (m *MCParticle) GetSpin() []float32 {
	if m != nil {
		return m.Spin
	}
	return nil
}

func (m *MCParticle) GetColorFlow() []int32 {
	if m != nil {
		return m.ColorFlow
	}
	return nil
}

func (m *MCParticle) GetGenStatus() int32 {
	if m != nil {
		return m.GenStatus
	}
	return 0
}

func (m *MCParticle) GetSimStatus() uint32 {
	if m != nil {
		return m.SimStatus
	}
	return 0
}

type MCParticleCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*MCParticle       `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *MCParticleCollection) Reset()                    { *m = MCParticleCollection{} }
func (m *MCParticleCollection) String() string            { return proto.CompactTextString(m) }
func (*MCParticleCollection) ProtoMessage()               {}
func (*MCParticleCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{2} }

func (m *MCParticleCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MCParticleCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *MCParticleCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *MCParticleCollection) GetEntries() []*MCParticle {
	if m != nil {
		return m.Entries
	}
	return nil
}

type SimTrackerHit struct {
	Id         uint32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0    int32                  `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1    int32                  `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Pos        []float64              `protobuf:"fixed64,4,rep,packed,name=pos" json:"pos,omitempty"`
	EDep       float32                `protobuf:"fixed32,5,opt,name=EDep,proto3" json:"EDep,omitempty"`
	Time       float32                `protobuf:"fixed32,6,opt,name=time,proto3" json:"time,omitempty"`
	Mc         *proio_model.Reference `protobuf:"bytes,7,opt,name=mc" json:"mc,omitempty"`
	P          []float32              `protobuf:"fixed32,8,rep,packed,name=p" json:"p,omitempty"`
	PathLength float32                `protobuf:"fixed32,9,opt,name=pathLength,proto3" json:"pathLength,omitempty"`
	Quality    int32                  `protobuf:"varint,10,opt,name=quality,proto3" json:"quality,omitempty"`
}

func (m *SimTrackerHit) Reset()                    { *m = SimTrackerHit{} }
func (m *SimTrackerHit) String() string            { return proto.CompactTextString(m) }
func (*SimTrackerHit) ProtoMessage()               {}
func (*SimTrackerHit) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{3} }

func (m *SimTrackerHit) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SimTrackerHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *SimTrackerHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *SimTrackerHit) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *SimTrackerHit) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *SimTrackerHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SimTrackerHit) GetMc() *proio_model.Reference {
	if m != nil {
		return m.Mc
	}
	return nil
}

func (m *SimTrackerHit) GetP() []float32 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *SimTrackerHit) GetPathLength() float32 {
	if m != nil {
		return m.PathLength
	}
	return 0
}

func (m *SimTrackerHit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

type SimTrackerHitCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*SimTrackerHit    `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *SimTrackerHitCollection) Reset()                    { *m = SimTrackerHitCollection{} }
func (m *SimTrackerHitCollection) String() string            { return proto.CompactTextString(m) }
func (*SimTrackerHitCollection) ProtoMessage()               {}
func (*SimTrackerHitCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{4} }

func (m *SimTrackerHitCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SimTrackerHitCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *SimTrackerHitCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SimTrackerHitCollection) GetEntries() []*SimTrackerHit {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerRawData struct {
	Id      uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32    `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32    `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    int32    `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
	ADCs    []uint32 `protobuf:"varint,5,rep,packed,name=ADCs" json:"ADCs,omitempty"`
}

func (m *TrackerRawData) Reset()                    { *m = TrackerRawData{} }
func (m *TrackerRawData) String() string            { return proto.CompactTextString(m) }
func (*TrackerRawData) ProtoMessage()               {}
func (*TrackerRawData) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{5} }

func (m *TrackerRawData) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerRawData) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerRawData) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerRawData) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerRawData) GetADCs() []uint32 {
	if m != nil {
		return m.ADCs
	}
	return nil
}

type TrackerRawDataCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerRawData   `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerRawDataCollection) Reset()                    { *m = TrackerRawDataCollection{} }
func (m *TrackerRawDataCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerRawDataCollection) ProtoMessage()               {}
func (*TrackerRawDataCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{6} }

func (m *TrackerRawDataCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerRawDataCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerRawDataCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerRawDataCollection) GetEntries() []*TrackerRawData {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerData struct {
	Id      uint32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32     `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32     `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    float32   `protobuf:"fixed32,4,opt,name=time,proto3" json:"time,omitempty"`
	Charges []float32 `protobuf:"fixed32,5,rep,packed,name=charges" json:"charges,omitempty"`
}

func (m *TrackerData) Reset()                    { *m = TrackerData{} }
func (m *TrackerData) String() string            { return proto.CompactTextString(m) }
func (*TrackerData) ProtoMessage()               {}
func (*TrackerData) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{7} }

func (m *TrackerData) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerData) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerData) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerData) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerData) GetCharges() []float32 {
	if m != nil {
		return m.Charges
	}
	return nil
}

type TrackerDataCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerData      `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerDataCollection) Reset()                    { *m = TrackerDataCollection{} }
func (m *TrackerDataCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerDataCollection) ProtoMessage()               {}
func (*TrackerDataCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{8} }

func (m *TrackerDataCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerDataCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerDataCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerDataCollection) GetEntries() []*TrackerData {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerHit struct {
	Id      uint32                   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32                    `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32                    `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32                    `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64                `protobuf:"fixed64,5,rep,packed,name=pos" json:"pos,omitempty"`
	Cov     []float64                `protobuf:"fixed64,6,rep,packed,name=cov" json:"cov,omitempty"`
	EDep    float32                  `protobuf:"fixed32,7,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32                  `protobuf:"fixed32,8,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32                  `protobuf:"fixed32,9,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32                    `protobuf:"varint,10,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []*proio_model.Reference `protobuf:"bytes,11,rep,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHit) Reset()                    { *m = TrackerHit{} }
func (m *TrackerHit) String() string            { return proto.CompactTextString(m) }
func (*TrackerHit) ProtoMessage()               {}
func (*TrackerHit) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{9} }

func (m *TrackerHit) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHit) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHit) GetCov() []float64 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *TrackerHit) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHit) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHit) GetRawHits() []*proio_model.Reference {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerHitCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerHit       `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerHitCollection) Reset()                    { *m = TrackerHitCollection{} }
func (m *TrackerHitCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitCollection) ProtoMessage()               {}
func (*TrackerHitCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{10} }

func (m *TrackerHitCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHitCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerHitCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerHitCollection) GetEntries() []*TrackerHit {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerPulse struct {
	Id      uint32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32                  `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32                  `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    float32                `protobuf:"fixed32,4,opt,name=time,proto3" json:"time,omitempty"`
	Charge  float32                `protobuf:"fixed32,5,opt,name=charge,proto3" json:"charge,omitempty"`
	Cov     []float32              `protobuf:"fixed32,6,rep,packed,name=cov" json:"cov,omitempty"`
	Quality int32                  `protobuf:"varint,7,opt,name=quality,proto3" json:"quality,omitempty"`
	TPC     *proio_model.Reference `protobuf:"bytes,8,opt,name=TPC" json:"TPC,omitempty"`
}

func (m *TrackerPulse) Reset()                    { *m = TrackerPulse{} }
func (m *TrackerPulse) String() string            { return proto.CompactTextString(m) }
func (*TrackerPulse) ProtoMessage()               {}
func (*TrackerPulse) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{11} }

func (m *TrackerPulse) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerPulse) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerPulse) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerPulse) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerPulse) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *TrackerPulse) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *TrackerPulse) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerPulse) GetTPC() *proio_model.Reference {
	if m != nil {
		return m.TPC
	}
	return nil
}

type TrackerPulseCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerPulse     `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerPulseCollection) Reset()                    { *m = TrackerPulseCollection{} }
func (m *TrackerPulseCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerPulseCollection) ProtoMessage()               {}
func (*TrackerPulseCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{12} }

func (m *TrackerPulseCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerPulseCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerPulseCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerPulseCollection) GetEntries() []*TrackerPulse {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerHitPlane struct {
	Id      uint32                   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32                    `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32                    `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32                    `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64                `protobuf:"fixed64,5,rep,packed,name=pos" json:"pos,omitempty"`
	U       []float32                `protobuf:"fixed32,6,rep,packed,name=U" json:"U,omitempty"`
	V       []float32                `protobuf:"fixed32,7,rep,packed,name=V" json:"V,omitempty"`
	DU      float32                  `protobuf:"fixed32,8,opt,name=dU,proto3" json:"dU,omitempty"`
	DV      float32                  `protobuf:"fixed32,9,opt,name=dV,proto3" json:"dV,omitempty"`
	EDep    float32                  `protobuf:"fixed32,10,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32                  `protobuf:"fixed32,11,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32                  `protobuf:"fixed32,12,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32                    `protobuf:"varint,13,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []*proio_model.Reference `protobuf:"bytes,14,rep,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHitPlane) Reset()                    { *m = TrackerHitPlane{} }
func (m *TrackerHitPlane) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitPlane) ProtoMessage()               {}
func (*TrackerHitPlane) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{13} }

func (m *TrackerHitPlane) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHitPlane) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHitPlane) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHitPlane) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHitPlane) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHitPlane) GetU() []float32 {
	if m != nil {
		return m.U
	}
	return nil
}

func (m *TrackerHitPlane) GetV() []float32 {
	if m != nil {
		return m.V
	}
	return nil
}

func (m *TrackerHitPlane) GetDU() float32 {
	if m != nil {
		return m.DU
	}
	return 0
}

func (m *TrackerHitPlane) GetDV() float32 {
	if m != nil {
		return m.DV
	}
	return 0
}

func (m *TrackerHitPlane) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHitPlane) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHitPlane) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHitPlane) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHitPlane) GetRawHits() []*proio_model.Reference {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerHitPlaneCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerHitPlane  `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerHitPlaneCollection) Reset()                    { *m = TrackerHitPlaneCollection{} }
func (m *TrackerHitPlaneCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitPlaneCollection) ProtoMessage()               {}
func (*TrackerHitPlaneCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{14} }

func (m *TrackerHitPlaneCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHitPlaneCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerHitPlaneCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerHitPlaneCollection) GetEntries() []*TrackerHitPlane {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerHitZCylinder struct {
	Id      uint32                   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32                    `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32                    `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32                    `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64                `protobuf:"fixed64,5,rep,packed,name=pos" json:"pos,omitempty"`
	Center  []float32                `protobuf:"fixed32,6,rep,packed,name=center" json:"center,omitempty"`
	DRPhi   float32                  `protobuf:"fixed32,7,opt,name=dRPhi,proto3" json:"dRPhi,omitempty"`
	DZ      float32                  `protobuf:"fixed32,8,opt,name=dZ,proto3" json:"dZ,omitempty"`
	EDep    float32                  `protobuf:"fixed32,9,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32                  `protobuf:"fixed32,10,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32                  `protobuf:"fixed32,11,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32                    `protobuf:"varint,12,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []*proio_model.Reference `protobuf:"bytes,13,rep,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHitZCylinder) Reset()                    { *m = TrackerHitZCylinder{} }
func (m *TrackerHitZCylinder) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitZCylinder) ProtoMessage()               {}
func (*TrackerHitZCylinder) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{15} }

func (m *TrackerHitZCylinder) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHitZCylinder) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHitZCylinder) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHitZCylinder) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHitZCylinder) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHitZCylinder) GetCenter() []float32 {
	if m != nil {
		return m.Center
	}
	return nil
}

func (m *TrackerHitZCylinder) GetDRPhi() float32 {
	if m != nil {
		return m.DRPhi
	}
	return 0
}

func (m *TrackerHitZCylinder) GetDZ() float32 {
	if m != nil {
		return m.DZ
	}
	return 0
}

func (m *TrackerHitZCylinder) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHitZCylinder) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHitZCylinder) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHitZCylinder) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHitZCylinder) GetRawHits() []*proio_model.Reference {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerHitZCylinderCollection struct {
	Id      uint32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32                 `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params    `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerHitZCylinder `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerHitZCylinderCollection) Reset()         { *m = TrackerHitZCylinderCollection{} }
func (m *TrackerHitZCylinderCollection) String() string { return proto.CompactTextString(m) }
func (*TrackerHitZCylinderCollection) ProtoMessage()    {}
func (*TrackerHitZCylinderCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorLcio, []int{16}
}

func (m *TrackerHitZCylinderCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHitZCylinderCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerHitZCylinderCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerHitZCylinderCollection) GetEntries() []*TrackerHitZCylinder {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Track struct {
	Id         uint32                   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type       int32                    `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Chi2       float32                  `protobuf:"fixed32,3,opt,name=chi2,proto3" json:"chi2,omitempty"`
	NDF        int32                    `protobuf:"varint,4,opt,name=NDF,proto3" json:"NDF,omitempty"`
	DEdx       float32                  `protobuf:"fixed32,5,opt,name=dEdx,proto3" json:"dEdx,omitempty"`
	DEdxErr    float32                  `protobuf:"fixed32,6,opt,name=dEdxErr,proto3" json:"dEdxErr,omitempty"`
	Radius     float32                  `protobuf:"fixed32,7,opt,name=radius,proto3" json:"radius,omitempty"`
	SubDetHits []int32                  `protobuf:"varint,8,rep,packed,name=subDetHits" json:"subDetHits,omitempty"`
	States     []*Track_TrackState      `protobuf:"bytes,9,rep,name=states" json:"states,omitempty"`
	Hits       []*proio_model.Reference `protobuf:"bytes,10,rep,name=hits" json:"hits,omitempty"`
	Tracks     []*proio_model.Reference `protobuf:"bytes,11,rep,name=tracks" json:"tracks,omitempty"`
}

func (m *Track) Reset()                    { *m = Track{} }
func (m *Track) String() string            { return proto.CompactTextString(m) }
func (*Track) ProtoMessage()               {}
func (*Track) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{17} }

func (m *Track) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Track) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Track) GetChi2() float32 {
	if m != nil {
		return m.Chi2
	}
	return 0
}

func (m *Track) GetNDF() int32 {
	if m != nil {
		return m.NDF
	}
	return 0
}

func (m *Track) GetDEdx() float32 {
	if m != nil {
		return m.DEdx
	}
	return 0
}

func (m *Track) GetDEdxErr() float32 {
	if m != nil {
		return m.DEdxErr
	}
	return 0
}

func (m *Track) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *Track) GetSubDetHits() []int32 {
	if m != nil {
		return m.SubDetHits
	}
	return nil
}

func (m *Track) GetStates() []*Track_TrackState {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *Track) GetHits() []*proio_model.Reference {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *Track) GetTracks() []*proio_model.Reference {
	if m != nil {
		return m.Tracks
	}
	return nil
}

type Track_TrackState struct {
	Loc   int32     `protobuf:"varint,1,opt,name=loc,proto3" json:"loc,omitempty"`
	D0    float32   `protobuf:"fixed32,2,opt,name=d0,proto3" json:"d0,omitempty"`
	Phi   float32   `protobuf:"fixed32,3,opt,name=phi,proto3" json:"phi,omitempty"`
	Omega float32   `protobuf:"fixed32,4,opt,name=omega,proto3" json:"omega,omitempty"`
	Z0    float32   `protobuf:"fixed32,5,opt,name=z0,proto3" json:"z0,omitempty"`
	TanL  float32   `protobuf:"fixed32,6,opt,name=tanL,proto3" json:"tanL,omitempty"`
	Cov   []float32 `protobuf:"fixed32,7,rep,packed,name=cov" json:"cov,omitempty"`
	Ref   []float32 `protobuf:"fixed32,8,rep,packed,name=ref" json:"ref,omitempty"`
}

func (m *Track_TrackState) Reset()                    { *m = Track_TrackState{} }
func (m *Track_TrackState) String() string            { return proto.CompactTextString(m) }
func (*Track_TrackState) ProtoMessage()               {}
func (*Track_TrackState) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{17, 0} }

func (m *Track_TrackState) GetLoc() int32 {
	if m != nil {
		return m.Loc
	}
	return 0
}

func (m *Track_TrackState) GetD0() float32 {
	if m != nil {
		return m.D0
	}
	return 0
}

func (m *Track_TrackState) GetPhi() float32 {
	if m != nil {
		return m.Phi
	}
	return 0
}

func (m *Track_TrackState) GetOmega() float32 {
	if m != nil {
		return m.Omega
	}
	return 0
}

func (m *Track_TrackState) GetZ0() float32 {
	if m != nil {
		return m.Z0
	}
	return 0
}

func (m *Track_TrackState) GetTanL() float32 {
	if m != nil {
		return m.TanL
	}
	return 0
}

func (m *Track_TrackState) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *Track_TrackState) GetRef() []float32 {
	if m != nil {
		return m.Ref
	}
	return nil
}

type TrackCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*Track            `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackCollection) Reset()                    { *m = TrackCollection{} }
func (m *TrackCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackCollection) ProtoMessage()               {}
func (*TrackCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{18} }

func (m *TrackCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackCollection) GetEntries() []*Track {
	if m != nil {
		return m.Entries
	}
	return nil
}

type SimCalorimeterHit struct {
	Id            uint32                       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Params        *proio_model.Params          `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	CellID0       int32                        `protobuf:"varint,3,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1       int32                        `protobuf:"varint,4,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Energy        float32                      `protobuf:"fixed32,5,opt,name=energy,proto3" json:"energy,omitempty"`
	Pos           []float32                    `protobuf:"fixed32,6,rep,packed,name=pos" json:"pos,omitempty"`
	Contributions []*SimCalorimeterHit_Contrib `protobuf:"bytes,7,rep,name=contributions" json:"contributions,omitempty"`
}

func (m *SimCalorimeterHit) Reset()                    { *m = SimCalorimeterHit{} }
func (m *SimCalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*SimCalorimeterHit) ProtoMessage()               {}
func (*SimCalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{19} }

func (m *SimCalorimeterHit) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SimCalorimeterHit) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SimCalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *SimCalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *SimCalorimeterHit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *SimCalorimeterHit) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *SimCalorimeterHit) GetContributions() []*SimCalorimeterHit_Contrib {
	if m != nil {
		return m.Contributions
	}
	return nil
}

type SimCalorimeterHit_Contrib struct {
	MCParticle *proio_model.Reference `protobuf:"bytes,1,opt,name=MCParticle" json:"MCParticle,omitempty"`
	Energy     float32                `protobuf:"fixed32,2,opt,name=energy,proto3" json:"energy,omitempty"`
	Time       float32                `protobuf:"fixed32,3,opt,name=time,proto3" json:"time,omitempty"`
	PDG        int32                  `protobuf:"varint,4,opt,name=PDG,proto3" json:"PDG,omitempty"`
	StepPos    []float32              `protobuf:"fixed32,5,rep,packed,name=stepPos" json:"stepPos,omitempty"`
}

func (m *SimCalorimeterHit_Contrib) Reset()         { *m = SimCalorimeterHit_Contrib{} }
func (m *SimCalorimeterHit_Contrib) String() string { return proto.CompactTextString(m) }
func (*SimCalorimeterHit_Contrib) ProtoMessage()    {}
func (*SimCalorimeterHit_Contrib) Descriptor() ([]byte, []int) {
	return fileDescriptorLcio, []int{19, 0}
}

func (m *SimCalorimeterHit_Contrib) GetMCParticle() *proio_model.Reference {
	if m != nil {
		return m.MCParticle
	}
	return nil
}

func (m *SimCalorimeterHit_Contrib) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetStepPos() []float32 {
	if m != nil {
		return m.StepPos
	}
	return nil
}

type SimCalorimeterHitCollection struct {
	Id      uint32               `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32               `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params  `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*SimCalorimeterHit `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *SimCalorimeterHitCollection) Reset()                    { *m = SimCalorimeterHitCollection{} }
func (m *SimCalorimeterHitCollection) String() string            { return proto.CompactTextString(m) }
func (*SimCalorimeterHitCollection) ProtoMessage()               {}
func (*SimCalorimeterHitCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{20} }

func (m *SimCalorimeterHitCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SimCalorimeterHitCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *SimCalorimeterHitCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SimCalorimeterHitCollection) GetEntries() []*SimCalorimeterHit {
	if m != nil {
		return m.Entries
	}
	return nil
}

type RawCalorimeterHit struct {
	Id        uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0   int32  `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1   int32  `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Amplitude int32  `protobuf:"varint,4,opt,name=amplitude,proto3" json:"amplitude,omitempty"`
	TimeStamp int32  `protobuf:"varint,5,opt,name=timeStamp,proto3" json:"timeStamp,omitempty"`
}

func (m *RawCalorimeterHit) Reset()                    { *m = RawCalorimeterHit{} }
func (m *RawCalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*RawCalorimeterHit) ProtoMessage()               {}
func (*RawCalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{21} }

func (m *RawCalorimeterHit) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RawCalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *RawCalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *RawCalorimeterHit) GetAmplitude() int32 {
	if m != nil {
		return m.Amplitude
	}
	return 0
}

func (m *RawCalorimeterHit) GetTimeStamp() int32 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

type RawCalorimeterHitCollection struct {
	Id      uint32               `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32               `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params  `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*RawCalorimeterHit `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *RawCalorimeterHitCollection) Reset()                    { *m = RawCalorimeterHitCollection{} }
func (m *RawCalorimeterHitCollection) String() string            { return proto.CompactTextString(m) }
func (*RawCalorimeterHitCollection) ProtoMessage()               {}
func (*RawCalorimeterHitCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{22} }

func (m *RawCalorimeterHitCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RawCalorimeterHitCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RawCalorimeterHitCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *RawCalorimeterHitCollection) GetEntries() []*RawCalorimeterHit {
	if m != nil {
		return m.Entries
	}
	return nil
}

type CalorimeterHit struct {
	Id        uint32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0   int32                  `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1   int32                  `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Energy    float32                `protobuf:"fixed32,4,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyErr float32                `protobuf:"fixed32,5,opt,name=energyErr,proto3" json:"energyErr,omitempty"`
	Time      float32                `protobuf:"fixed32,6,opt,name=time,proto3" json:"time,omitempty"`
	Pos       []float32              `protobuf:"fixed32,7,rep,packed,name=pos" json:"pos,omitempty"`
	Type      int32                  `protobuf:"varint,8,opt,name=type,proto3" json:"type,omitempty"`
	Raw       *proio_model.Reference `protobuf:"bytes,9,opt,name=raw" json:"raw,omitempty"`
}

func (m *CalorimeterHit) Reset()                    { *m = CalorimeterHit{} }
func (m *CalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*CalorimeterHit) ProtoMessage()               {}
func (*CalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{23} }

func (m *CalorimeterHit) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *CalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *CalorimeterHit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *CalorimeterHit) GetEnergyErr() float32 {
	if m != nil {
		return m.EnergyErr
	}
	return 0
}

func (m *CalorimeterHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *CalorimeterHit) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *CalorimeterHit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CalorimeterHit) GetRaw() *proio_model.Reference {
	if m != nil {
		return m.Raw
	}
	return nil
}

type CalorimeterHitCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*CalorimeterHit   `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *CalorimeterHitCollection) Reset()                    { *m = CalorimeterHitCollection{} }
func (m *CalorimeterHitCollection) String() string            { return proto.CompactTextString(m) }
func (*CalorimeterHitCollection) ProtoMessage()               {}
func (*CalorimeterHitCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{24} }

func (m *CalorimeterHitCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CalorimeterHitCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *CalorimeterHitCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *CalorimeterHitCollection) GetEntries() []*CalorimeterHit {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Cluster struct {
	Id         uint32                   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type       int32                    `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Energy     float32                  `protobuf:"fixed32,3,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyErr  float32                  `protobuf:"fixed32,4,opt,name=energyErr,proto3" json:"energyErr,omitempty"`
	Pos        []float32                `protobuf:"fixed32,5,rep,packed,name=pos" json:"pos,omitempty"`
	PosErr     []float32                `protobuf:"fixed32,6,rep,packed,name=posErr" json:"posErr,omitempty"`
	Theta      float32                  `protobuf:"fixed32,7,opt,name=theta,proto3" json:"theta,omitempty"`
	Phi        float32                  `protobuf:"fixed32,8,opt,name=phi,proto3" json:"phi,omitempty"`
	DirErr     []float32                `protobuf:"fixed32,9,rep,packed,name=dirErr" json:"dirErr,omitempty"`
	Shape      []float32                `protobuf:"fixed32,10,rep,packed,name=shape" json:"shape,omitempty"`
	PIDs       []*ParticleID            `protobuf:"bytes,11,rep,name=PIDs" json:"PIDs,omitempty"`
	Clusters   []*proio_model.Reference `protobuf:"bytes,12,rep,name=clusters" json:"clusters,omitempty"`
	Hits       []*proio_model.Reference `protobuf:"bytes,13,rep,name=hits" json:"hits,omitempty"`
	Weights    []float32                `protobuf:"fixed32,14,rep,packed,name=weights" json:"weights,omitempty"`
	SubDetEnes []float32                `protobuf:"fixed32,15,rep,packed,name=subDetEnes" json:"subDetEnes,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{25} }

func (m *Cluster) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Cluster) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Cluster) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *Cluster) GetEnergyErr() float32 {
	if m != nil {
		return m.EnergyErr
	}
	return 0
}

func (m *Cluster) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Cluster) GetPosErr() []float32 {
	if m != nil {
		return m.PosErr
	}
	return nil
}

func (m *Cluster) GetTheta() float32 {
	if m != nil {
		return m.Theta
	}
	return 0
}

func (m *Cluster) GetPhi() float32 {
	if m != nil {
		return m.Phi
	}
	return 0
}

func (m *Cluster) GetDirErr() []float32 {
	if m != nil {
		return m.DirErr
	}
	return nil
}

func (m *Cluster) GetShape() []float32 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *Cluster) GetPIDs() []*ParticleID {
	if m != nil {
		return m.PIDs
	}
	return nil
}

func (m *Cluster) GetClusters() []*proio_model.Reference {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *Cluster) GetHits() []*proio_model.Reference {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *Cluster) GetWeights() []float32 {
	if m != nil {
		return m.Weights
	}
	return nil
}

func (m *Cluster) GetSubDetEnes() []float32 {
	if m != nil {
		return m.SubDetEnes
	}
	return nil
}

type ClusterCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*Cluster          `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *ClusterCollection) Reset()                    { *m = ClusterCollection{} }
func (m *ClusterCollection) String() string            { return proto.CompactTextString(m) }
func (*ClusterCollection) ProtoMessage()               {}
func (*ClusterCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{26} }

func (m *ClusterCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ClusterCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ClusterCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *ClusterCollection) GetEntries() []*Cluster {
	if m != nil {
		return m.Entries
	}
	return nil
}

type RecParticle struct {
	Id            uint32                   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type          int32                    `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	P             []float32                `protobuf:"fixed32,3,rep,packed,name=p" json:"p,omitempty"`
	Energy        float32                  `protobuf:"fixed32,4,opt,name=energy,proto3" json:"energy,omitempty"`
	Cov           []float32                `protobuf:"fixed32,5,rep,packed,name=cov" json:"cov,omitempty"`
	Mass          float32                  `protobuf:"fixed32,6,opt,name=mass,proto3" json:"mass,omitempty"`
	Charge        float32                  `protobuf:"fixed32,7,opt,name=charge,proto3" json:"charge,omitempty"`
	Ref           []float32                `protobuf:"fixed32,8,rep,packed,name=ref" json:"ref,omitempty"`
	PIDs          []*ParticleID            `protobuf:"bytes,9,rep,name=PIDs" json:"PIDs,omitempty"`
	PIDUsed       int32                    `protobuf:"varint,10,opt,name=PIDUsed,proto3" json:"PIDUsed,omitempty"`
	GoodnessOfPID float32                  `protobuf:"fixed32,11,opt,name=goodnessOfPID,proto3" json:"goodnessOfPID,omitempty"`
	Recs          []*proio_model.Reference `protobuf:"bytes,12,rep,name=recs" json:"recs,omitempty"`
	Tracks        []*proio_model.Reference `protobuf:"bytes,13,rep,name=tracks" json:"tracks,omitempty"`
	Clusters      []*proio_model.Reference `protobuf:"bytes,14,rep,name=clusters" json:"clusters,omitempty"`
	StartVtx      *proio_model.Reference   `protobuf:"bytes,15,opt,name=startVtx" json:"startVtx,omitempty"`
}

func (m *RecParticle) Reset()                    { *m = RecParticle{} }
func (m *RecParticle) String() string            { return proto.CompactTextString(m) }
func (*RecParticle) ProtoMessage()               {}
func (*RecParticle) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{27} }

func (m *RecParticle) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RecParticle) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RecParticle) GetP() []float32 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *RecParticle) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *RecParticle) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *RecParticle) GetMass() float32 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *RecParticle) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *RecParticle) GetRef() []float32 {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *RecParticle) GetPIDs() []*ParticleID {
	if m != nil {
		return m.PIDs
	}
	return nil
}

func (m *RecParticle) GetPIDUsed() int32 {
	if m != nil {
		return m.PIDUsed
	}
	return 0
}

func (m *RecParticle) GetGoodnessOfPID() float32 {
	if m != nil {
		return m.GoodnessOfPID
	}
	return 0
}

func (m *RecParticle) GetRecs() []*proio_model.Reference {
	if m != nil {
		return m.Recs
	}
	return nil
}

func (m *RecParticle) GetTracks() []*proio_model.Reference {
	if m != nil {
		return m.Tracks
	}
	return nil
}

func (m *RecParticle) GetClusters() []*proio_model.Reference {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *RecParticle) GetStartVtx() *proio_model.Reference {
	if m != nil {
		return m.StartVtx
	}
	return nil
}

type RecParticleCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*RecParticle      `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *RecParticleCollection) Reset()                    { *m = RecParticleCollection{} }
func (m *RecParticleCollection) String() string            { return proto.CompactTextString(m) }
func (*RecParticleCollection) ProtoMessage()               {}
func (*RecParticleCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{28} }

func (m *RecParticleCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RecParticleCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RecParticleCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *RecParticleCollection) GetEntries() []*RecParticle {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Vertex struct {
	Id      uint32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Primary int32                  `protobuf:"varint,2,opt,name=primary,proto3" json:"primary,omitempty"`
	AlgType int32                  `protobuf:"varint,3,opt,name=algType,proto3" json:"algType,omitempty"`
	Chi2    float32                `protobuf:"fixed32,4,opt,name=chi2,proto3" json:"chi2,omitempty"`
	Prob    float32                `protobuf:"fixed32,5,opt,name=prob,proto3" json:"prob,omitempty"`
	Pos     []float32              `protobuf:"fixed32,6,rep,packed,name=pos" json:"pos,omitempty"`
	Cov     []float32              `protobuf:"fixed32,7,rep,packed,name=cov" json:"cov,omitempty"`
	Params  []float32              `protobuf:"fixed32,8,rep,packed,name=params" json:"params,omitempty"`
	RecPart *proio_model.Reference `protobuf:"bytes,9,opt,name=recPart" json:"recPart,omitempty"`
}

func (m *Vertex) Reset()                    { *m = Vertex{} }
func (m *Vertex) String() string            { return proto.CompactTextString(m) }
func (*Vertex) ProtoMessage()               {}
func (*Vertex) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{29} }

func (m *Vertex) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Vertex) GetPrimary() int32 {
	if m != nil {
		return m.Primary
	}
	return 0
}

func (m *Vertex) GetAlgType() int32 {
	if m != nil {
		return m.AlgType
	}
	return 0
}

func (m *Vertex) GetChi2() float32 {
	if m != nil {
		return m.Chi2
	}
	return 0
}

func (m *Vertex) GetProb() float32 {
	if m != nil {
		return m.Prob
	}
	return 0
}

func (m *Vertex) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Vertex) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *Vertex) GetParams() []float32 {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Vertex) GetRecPart() *proio_model.Reference {
	if m != nil {
		return m.RecPart
	}
	return nil
}

type VertexCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*Vertex           `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *VertexCollection) Reset()                    { *m = VertexCollection{} }
func (m *VertexCollection) String() string            { return proto.CompactTextString(m) }
func (*VertexCollection) ProtoMessage()               {}
func (*VertexCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{30} }

func (m *VertexCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *VertexCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *VertexCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *VertexCollection) GetEntries() []*Vertex {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Relation struct {
	Id     uint32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	From   *proio_model.Reference `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	To     *proio_model.Reference `protobuf:"bytes,3,opt,name=to" json:"to,omitempty"`
	Weight float32                `protobuf:"fixed32,4,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *Relation) Reset()                    { *m = Relation{} }
func (m *Relation) String() string            { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()               {}
func (*Relation) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{31} }

func (m *Relation) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Relation) GetFrom() *proio_model.Reference {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Relation) GetTo() *proio_model.Reference {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *Relation) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

type RelationCollection struct {
	Id      uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32              `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *proio_model.Params `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*Relation         `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *RelationCollection) Reset()                    { *m = RelationCollection{} }
func (m *RelationCollection) String() string            { return proto.CompactTextString(m) }
func (*RelationCollection) ProtoMessage()               {}
func (*RelationCollection) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{32} }

func (m *RelationCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RelationCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RelationCollection) GetParams() *proio_model.Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *RelationCollection) GetEntries() []*Relation {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterType((*ParticleID)(nil), "proio.model.lcio.ParticleID")
	proto.RegisterType((*MCParticle)(nil), "proio.model.lcio.MCParticle")
	proto.RegisterType((*MCParticleCollection)(nil), "proio.model.lcio.MCParticleCollection")
	proto.RegisterType((*SimTrackerHit)(nil), "proio.model.lcio.SimTrackerHit")
	proto.RegisterType((*SimTrackerHitCollection)(nil), "proio.model.lcio.SimTrackerHitCollection")
	proto.RegisterType((*TrackerRawData)(nil), "proio.model.lcio.TrackerRawData")
	proto.RegisterType((*TrackerRawDataCollection)(nil), "proio.model.lcio.TrackerRawDataCollection")
	proto.RegisterType((*TrackerData)(nil), "proio.model.lcio.TrackerData")
	proto.RegisterType((*TrackerDataCollection)(nil), "proio.model.lcio.TrackerDataCollection")
	proto.RegisterType((*TrackerHit)(nil), "proio.model.lcio.TrackerHit")
	proto.RegisterType((*TrackerHitCollection)(nil), "proio.model.lcio.TrackerHitCollection")
	proto.RegisterType((*TrackerPulse)(nil), "proio.model.lcio.TrackerPulse")
	proto.RegisterType((*TrackerPulseCollection)(nil), "proio.model.lcio.TrackerPulseCollection")
	proto.RegisterType((*TrackerHitPlane)(nil), "proio.model.lcio.TrackerHitPlane")
	proto.RegisterType((*TrackerHitPlaneCollection)(nil), "proio.model.lcio.TrackerHitPlaneCollection")
	proto.RegisterType((*TrackerHitZCylinder)(nil), "proio.model.lcio.TrackerHitZCylinder")
	proto.RegisterType((*TrackerHitZCylinderCollection)(nil), "proio.model.lcio.TrackerHitZCylinderCollection")
	proto.RegisterType((*Track)(nil), "proio.model.lcio.Track")
	proto.RegisterType((*Track_TrackState)(nil), "proio.model.lcio.Track.TrackState")
	proto.RegisterType((*TrackCollection)(nil), "proio.model.lcio.TrackCollection")
	proto.RegisterType((*SimCalorimeterHit)(nil), "proio.model.lcio.SimCalorimeterHit")
	proto.RegisterType((*SimCalorimeterHit_Contrib)(nil), "proio.model.lcio.SimCalorimeterHit.Contrib")
	proto.RegisterType((*SimCalorimeterHitCollection)(nil), "proio.model.lcio.SimCalorimeterHitCollection")
	proto.RegisterType((*RawCalorimeterHit)(nil), "proio.model.lcio.RawCalorimeterHit")
	proto.RegisterType((*RawCalorimeterHitCollection)(nil), "proio.model.lcio.RawCalorimeterHitCollection")
	proto.RegisterType((*CalorimeterHit)(nil), "proio.model.lcio.CalorimeterHit")
	proto.RegisterType((*CalorimeterHitCollection)(nil), "proio.model.lcio.CalorimeterHitCollection")
	proto.RegisterType((*Cluster)(nil), "proio.model.lcio.Cluster")
	proto.RegisterType((*ClusterCollection)(nil), "proio.model.lcio.ClusterCollection")
	proto.RegisterType((*RecParticle)(nil), "proio.model.lcio.RecParticle")
	proto.RegisterType((*RecParticleCollection)(nil), "proio.model.lcio.RecParticleCollection")
	proto.RegisterType((*Vertex)(nil), "proio.model.lcio.Vertex")
	proto.RegisterType((*VertexCollection)(nil), "proio.model.lcio.VertexCollection")
	proto.RegisterType((*Relation)(nil), "proio.model.lcio.Relation")
	proto.RegisterType((*RelationCollection)(nil), "proio.model.lcio.RelationCollection")
}
func (m *ParticleID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParticleID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Likelihood != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Likelihood))))
		i += 4
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.PDG != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PDG))
	}
	if m.AlgType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.AlgType))
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Params)*4))
		for _, num := range m.Params {
			f1 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f1))
			i += 4
		}
	}
	return i, nil
}

func (m *MCParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MCParticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if len(m.Parents) > 0 {
		for _, msg := range m.Parents {
			dAtA[i] = 0x12
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PDG != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PDG))
	}
	if len(m.Vertex) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Vertex)*8))
		for _, num := range m.Vertex {
			f2 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f2))
			i += 8
		}
	}
	if m.Time != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.P)*8))
		for _, num := range m.P {
			f3 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f3))
			i += 8
		}
	}
	if m.Mass != 0 {
		dAtA[i] = 0x41
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mass))))
		i += 8
	}
	if m.Charge != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Charge))))
		i += 4
	}
	if len(m.PEndPoint) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.PEndPoint)*8))
		for _, num := range m.PEndPoint {
			f4 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f4))
			i += 8
		}
	}
	if len(m.Spin) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Spin)*4))
		for _, num := range m.Spin {
			f5 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f5))
			i += 4
		}
	}
	if len(m.ColorFlow) > 0 {
		dAtA7 := make([]byte, len(m.ColorFlow)*10)
		var j6 int
		for _, num1 := range m.ColorFlow {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.GenStatus != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.GenStatus))
	}
	if m.SimStatus != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.SimStatus))
	}
	return i, nil
}

func (m *MCParticleCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MCParticleCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n8, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SimTrackerHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimTrackerHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f9 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f9))
			i += 8
		}
	}
	if m.EDep != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Mc != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Mc.Size()))
		n10, err := m.Mc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.P)*4))
		for _, num := range m.P {
			f11 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f11))
			i += 4
		}
	}
	if m.PathLength != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PathLength))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	return i, nil
}

func (m *SimTrackerHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimTrackerHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n12, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerRawData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerRawData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Time))
	}
	if len(m.ADCs) > 0 {
		dAtA14 := make([]byte, len(m.ADCs)*10)
		var j13 int
		for _, num := range m.ADCs {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	return i, nil
}

func (m *TrackerRawDataCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerRawDataCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n15, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if len(m.Charges) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Charges)*4))
		for _, num := range m.Charges {
			f16 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f16))
			i += 4
		}
	}
	return i, nil
}

func (m *TrackerDataCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerDataCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n17, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f18 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f18))
			i += 8
		}
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*8))
		for _, num := range m.Cov {
			f19 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f19))
			i += 8
		}
	}
	if m.EDep != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDepErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, msg := range m.RawHits {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n20, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerPulse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerPulse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Charge != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Charge))))
		i += 4
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f21 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f21))
			i += 4
		}
	}
	if m.Quality != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if m.TPC != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.TPC.Size()))
		n22, err := m.TPC.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *TrackerPulseCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerPulseCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n23, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitPlane) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitPlane) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f24 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f24))
			i += 8
		}
	}
	if len(m.U) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.U)*4))
		for _, num := range m.U {
			f25 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f25))
			i += 4
		}
	}
	if len(m.V) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.V)*4))
		for _, num := range m.V {
			f26 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f26))
			i += 4
		}
	}
	if m.DU != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DU))))
		i += 4
	}
	if m.DV != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DV))))
		i += 4
	}
	if m.EDep != 0 {
		dAtA[i] = 0x55
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x5d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDepErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x65
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, msg := range m.RawHits {
			dAtA[i] = 0x72
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitPlaneCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitPlaneCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n27, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitZCylinder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitZCylinder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f28 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f28))
			i += 8
		}
	}
	if len(m.Center) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Center)*4))
		for _, num := range m.Center {
			f29 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f29))
			i += 4
		}
	}
	if m.DRPhi != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DRPhi))))
		i += 4
	}
	if m.DZ != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DZ))))
		i += 4
	}
	if m.EDep != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x55
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDepErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x5d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, msg := range m.RawHits {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitZCylinderCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitZCylinderCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n30, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Track) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Track) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.Chi2 != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Chi2))))
		i += 4
	}
	if m.NDF != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.NDF))
	}
	if m.DEdx != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DEdx))))
		i += 4
	}
	if m.DEdxErr != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DEdxErr))))
		i += 4
	}
	if m.Radius != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i += 4
	}
	if len(m.SubDetHits) > 0 {
		dAtA32 := make([]byte, len(m.SubDetHits)*10)
		var j31 int
		for _, num1 := range m.SubDetHits {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j31))
		i += copy(dAtA[i:], dAtA32[:j31])
	}
	if len(m.States) > 0 {
		for _, msg := range m.States {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hits) > 0 {
		for _, msg := range m.Hits {
			dAtA[i] = 0x52
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tracks) > 0 {
		for _, msg := range m.Tracks {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Track_TrackState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Track_TrackState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Loc != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Loc))
	}
	if m.D0 != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.D0))))
		i += 4
	}
	if m.Phi != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Phi))))
		i += 4
	}
	if m.Omega != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Omega))))
		i += 4
	}
	if m.Z0 != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z0))))
		i += 4
	}
	if m.TanL != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TanL))))
		i += 4
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f33 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f33))
			i += 4
		}
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Ref)*4))
		for _, num := range m.Ref {
			f34 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f34))
			i += 4
		}
	}
	return i, nil
}

func (m *TrackCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n35, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SimCalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n36, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f37 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f37))
			i += 4
		}
	}
	if len(m.Contributions) > 0 {
		for _, msg := range m.Contributions {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SimCalorimeterHit_Contrib) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHit_Contrib) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MCParticle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.MCParticle.Size()))
		n38, err := m.MCParticle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Energy != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.PDG != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PDG))
	}
	if len(m.StepPos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.StepPos)*4))
		for _, num := range m.StepPos {
			f39 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f39))
			i += 4
		}
	}
	return i, nil
}

func (m *SimCalorimeterHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n40, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawCalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Amplitude != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Amplitude))
	}
	if m.TimeStamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.TimeStamp))
	}
	return i, nil
}

func (m *RawCalorimeterHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCalorimeterHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n41, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if m.EnergyErr != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EnergyErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f42 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f42))
			i += 4
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.Raw != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Raw.Size()))
		n43, err := m.Raw.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *CalorimeterHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalorimeterHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n44, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if m.EnergyErr != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EnergyErr))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f45 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f45))
			i += 4
		}
	}
	if len(m.PosErr) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.PosErr)*4))
		for _, num := range m.PosErr {
			f46 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f46))
			i += 4
		}
	}
	if m.Theta != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Theta))))
		i += 4
	}
	if m.Phi != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Phi))))
		i += 4
	}
	if len(m.DirErr) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.DirErr)*4))
		for _, num := range m.DirErr {
			f47 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f47))
			i += 4
		}
	}
	if len(m.Shape) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Shape)*4))
		for _, num := range m.Shape {
			f48 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f48))
			i += 4
		}
	}
	if len(m.PIDs) > 0 {
		for _, msg := range m.PIDs {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Clusters) > 0 {
		for _, msg := range m.Clusters {
			dAtA[i] = 0x62
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hits) > 0 {
		for _, msg := range m.Hits {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Weights) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Weights)*4))
		for _, num := range m.Weights {
			f49 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f49))
			i += 4
		}
	}
	if len(m.SubDetEnes) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.SubDetEnes)*4))
		for _, num := range m.SubDetEnes {
			f50 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f50))
			i += 4
		}
	}
	return i, nil
}

func (m *ClusterCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n51, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RecParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecParticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.P)*4))
		for _, num := range m.P {
			f52 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f52))
			i += 4
		}
	}
	if m.Energy != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f53 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f53))
			i += 4
		}
	}
	if m.Mass != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Mass))))
		i += 4
	}
	if m.Charge != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Charge))))
		i += 4
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Ref)*4))
		for _, num := range m.Ref {
			f54 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f54))
			i += 4
		}
	}
	if len(m.PIDs) > 0 {
		for _, msg := range m.PIDs {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PIDUsed != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PIDUsed))
	}
	if m.GoodnessOfPID != 0 {
		dAtA[i] = 0x5d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GoodnessOfPID))))
		i += 4
	}
	if len(m.Recs) > 0 {
		for _, msg := range m.Recs {
			dAtA[i] = 0x62
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tracks) > 0 {
		for _, msg := range m.Tracks {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Clusters) > 0 {
		for _, msg := range m.Clusters {
			dAtA[i] = 0x72
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.StartVtx != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.StartVtx.Size()))
		n55, err := m.StartVtx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}

func (m *RecParticleCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecParticleCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n56, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Vertex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vertex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Primary != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Primary))
	}
	if m.AlgType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.AlgType))
	}
	if m.Chi2 != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Chi2))))
		i += 4
	}
	if m.Prob != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Prob))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f57 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f57))
			i += 4
		}
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f58 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f58))
			i += 4
		}
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Params)*4))
		for _, num := range m.Params {
			f59 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f59))
			i += 4
		}
	}
	if m.RecPart != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.RecPart.Size()))
		n60, err := m.RecPart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	return i, nil
}

func (m *VertexCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VertexCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n61, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Relation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.From.Size()))
		n62, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.To != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.To.Size()))
		n63, err := m.To.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.Weight != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Weight))))
		i += 4
	}
	return i, nil
}

func (m *RelationCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Params.Size()))
		n64, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintLcio(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ParticleID) Size() (n int) {
	var l int
	_ = l
	if m.Likelihood != 0 {
		n += 5
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.PDG != 0 {
		n += 1 + sovLcio(uint64(m.PDG))
	}
	if m.AlgType != 0 {
		n += 1 + sovLcio(uint64(m.AlgType))
	}
	if len(m.Params) > 0 {
		n += 1 + sovLcio(uint64(len(m.Params)*4)) + len(m.Params)*4
	}
	return n
}

func (m *MCParticle) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if len(m.Parents) > 0 {
		for _, e := range m.Parents {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if m.PDG != 0 {
		n += 1 + sovLcio(uint64(m.PDG))
	}
	if len(m.Vertex) > 0 {
		n += 1 + sovLcio(uint64(len(m.Vertex)*8)) + len(m.Vertex)*8
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.P) > 0 {
		n += 1 + sovLcio(uint64(len(m.P)*8)) + len(m.P)*8
	}
	if m.Mass != 0 {
		n += 9
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.PEndPoint) > 0 {
		n += 1 + sovLcio(uint64(len(m.PEndPoint)*8)) + len(m.PEndPoint)*8
	}
	if len(m.Spin) > 0 {
		n += 1 + sovLcio(uint64(len(m.Spin)*4)) + len(m.Spin)*4
	}
	if len(m.ColorFlow) > 0 {
		l = 0
		for _, e := range m.ColorFlow {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.GenStatus != 0 {
		n += 1 + sovLcio(uint64(m.GenStatus))
	}
	if m.SimStatus != 0 {
		n += 1 + sovLcio(uint64(m.SimStatus))
	}
	return n
}

func (m *MCParticleCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *SimTrackerHit) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Mc != nil {
		l = m.Mc.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.P) > 0 {
		n += 1 + sovLcio(uint64(len(m.P)*4)) + len(m.P)*4
	}
	if m.PathLength != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	return n
}

func (m *SimTrackerHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *TrackerRawData) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 1 + sovLcio(uint64(m.Time))
	}
	if len(m.ADCs) > 0 {
		l = 0
		for _, e := range m.ADCs {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	return n
}

func (m *TrackerRawDataCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *TrackerData) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.Charges) > 0 {
		n += 1 + sovLcio(uint64(len(m.Charges)*4)) + len(m.Charges)*4
	}
	return n
}

func (m *TrackerDataCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHit) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*8)) + len(m.Cov)*8
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, e := range m.RawHits {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *TrackerPulse) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if m.TPC != nil {
		l = m.TPC.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	return n
}

func (m *TrackerPulseCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitPlane) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.U) > 0 {
		n += 1 + sovLcio(uint64(len(m.U)*4)) + len(m.U)*4
	}
	if len(m.V) > 0 {
		n += 1 + sovLcio(uint64(len(m.V)*4)) + len(m.V)*4
	}
	if m.DU != 0 {
		n += 5
	}
	if m.DV != 0 {
		n += 5
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, e := range m.RawHits {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitPlaneCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitZCylinder) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.Center) > 0 {
		n += 1 + sovLcio(uint64(len(m.Center)*4)) + len(m.Center)*4
	}
	if m.DRPhi != 0 {
		n += 5
	}
	if m.DZ != 0 {
		n += 5
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, e := range m.RawHits {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitZCylinderCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *Track) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.Chi2 != 0 {
		n += 5
	}
	if m.NDF != 0 {
		n += 1 + sovLcio(uint64(m.NDF))
	}
	if m.DEdx != 0 {
		n += 5
	}
	if m.DEdxErr != 0 {
		n += 5
	}
	if m.Radius != 0 {
		n += 5
	}
	if len(m.SubDetHits) > 0 {
		l = 0
		for _, e := range m.SubDetHits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.States) > 0 {
		for _, e := range m.States {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Hits) > 0 {
		for _, e := range m.Hits {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Tracks) > 0 {
		for _, e := range m.Tracks {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *Track_TrackState) Size() (n int) {
	var l int
	_ = l
	if m.Loc != 0 {
		n += 1 + sovLcio(uint64(m.Loc))
	}
	if m.D0 != 0 {
		n += 5
	}
	if m.Phi != 0 {
		n += 5
	}
	if m.Omega != 0 {
		n += 5
	}
	if m.Z0 != 0 {
		n += 5
	}
	if m.TanL != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if len(m.Ref) > 0 {
		n += 1 + sovLcio(uint64(len(m.Ref)*4)) + len(m.Ref)*4
	}
	return n
}

func (m *TrackCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *SimCalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Energy != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.Contributions) > 0 {
		for _, e := range m.Contributions {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *SimCalorimeterHit_Contrib) Size() (n int) {
	var l int
	_ = l
	if m.MCParticle != nil {
		l = m.MCParticle.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.PDG != 0 {
		n += 1 + sovLcio(uint64(m.PDG))
	}
	if len(m.StepPos) > 0 {
		n += 1 + sovLcio(uint64(len(m.StepPos)*4)) + len(m.StepPos)*4
	}
	return n
}

func (m *SimCalorimeterHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *RawCalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Amplitude != 0 {
		n += 1 + sovLcio(uint64(m.Amplitude))
	}
	if m.TimeStamp != 0 {
		n += 1 + sovLcio(uint64(m.TimeStamp))
	}
	return n
}

func (m *RawCalorimeterHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *CalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.EnergyErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.Raw != nil {
		l = m.Raw.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	return n
}

func (m *CalorimeterHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.EnergyErr != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.PosErr) > 0 {
		n += 1 + sovLcio(uint64(len(m.PosErr)*4)) + len(m.PosErr)*4
	}
	if m.Theta != 0 {
		n += 5
	}
	if m.Phi != 0 {
		n += 5
	}
	if len(m.DirErr) > 0 {
		n += 1 + sovLcio(uint64(len(m.DirErr)*4)) + len(m.DirErr)*4
	}
	if len(m.Shape) > 0 {
		n += 1 + sovLcio(uint64(len(m.Shape)*4)) + len(m.Shape)*4
	}
	if len(m.PIDs) > 0 {
		for _, e := range m.PIDs {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Hits) > 0 {
		for _, e := range m.Hits {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Weights) > 0 {
		n += 1 + sovLcio(uint64(len(m.Weights)*4)) + len(m.Weights)*4
	}
	if len(m.SubDetEnes) > 0 {
		n += 1 + sovLcio(uint64(len(m.SubDetEnes)*4)) + len(m.SubDetEnes)*4
	}
	return n
}

func (m *ClusterCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *RecParticle) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.P) > 0 {
		n += 1 + sovLcio(uint64(len(m.P)*4)) + len(m.P)*4
	}
	if m.Energy != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if m.Mass != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.Ref) > 0 {
		n += 1 + sovLcio(uint64(len(m.Ref)*4)) + len(m.Ref)*4
	}
	if len(m.PIDs) > 0 {
		for _, e := range m.PIDs {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if m.PIDUsed != 0 {
		n += 1 + sovLcio(uint64(m.PIDUsed))
	}
	if m.GoodnessOfPID != 0 {
		n += 5
	}
	if len(m.Recs) > 0 {
		for _, e := range m.Recs {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Tracks) > 0 {
		for _, e := range m.Tracks {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if m.StartVtx != nil {
		l = m.StartVtx.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	return n
}

func (m *RecParticleCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *Vertex) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Primary != 0 {
		n += 1 + sovLcio(uint64(m.Primary))
	}
	if m.AlgType != 0 {
		n += 1 + sovLcio(uint64(m.AlgType))
	}
	if m.Chi2 != 0 {
		n += 5
	}
	if m.Prob != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if len(m.Params) > 0 {
		n += 1 + sovLcio(uint64(len(m.Params)*4)) + len(m.Params)*4
	}
	if m.RecPart != nil {
		l = m.RecPart.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	return n
}

func (m *VertexCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *Relation) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if m.Weight != 0 {
		n += 5
	}
	return n
}

func (m *RelationCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLcio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovLcio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovLcio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func sovLcio(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLcio(x uint64) (n int) {
	return sovLcio(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ParticleID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParticleID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParticleID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Likelihood", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Likelihood = float32(math.Float32frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgType", wireType)
			}
			m.AlgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Params = append(m.Params, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Params = append(m.Params, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MCParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MCParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MCParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parents = append(m.Parents, &proio_model.Reference{})
			if err := m.Parents[len(m.Parents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &proio_model.Reference{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Vertex = append(m.Vertex, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Vertex = append(m.Vertex, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vertex", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 7:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mass = float64(math.Float64frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Charge = float32(math.Float32frombits(v))
		case 10:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.PEndPoint = append(m.PEndPoint, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.PEndPoint = append(m.PEndPoint, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PEndPoint", wireType)
			}
		case 11:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Spin = append(m.Spin, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Spin = append(m.Spin, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Spin", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColorFlow = append(m.ColorFlow, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColorFlow = append(m.ColorFlow, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorFlow", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenStatus", wireType)
			}
			m.GenStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimStatus", wireType)
			}
			m.SimStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SimStatus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MCParticleCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MCParticleCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MCParticleCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &MCParticle{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimTrackerHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimTrackerHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimTrackerHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mc == nil {
				m.Mc = &proio_model.Reference{}
			}
			if err := m.Mc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathLength", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PathLength = float32(math.Float32frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimTrackerHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimTrackerHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimTrackerHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &SimTrackerHit{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerRawData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerRawData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerRawData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ADCs = append(m.ADCs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ADCs = append(m.ADCs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ADCs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerRawDataCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerRawDataCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerRawDataCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerRawData{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Charges = append(m.Charges, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Charges = append(m.Charges, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Charges", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerDataCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerDataCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerDataCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerData{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDepErr = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawHits = append(m.RawHits, &proio_model.Reference{})
			if err := m.RawHits[len(m.RawHits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerHit{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerPulse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerPulse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerPulse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Charge = float32(math.Float32frombits(v))
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TPC == nil {
				m.TPC = &proio_model.Reference{}
			}
			if err := m.TPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerPulseCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerPulseCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerPulseCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerPulse{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitPlane) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitPlane: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitPlane: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.U = append(m.U, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.U = append(m.U, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field U", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.V = append(m.V, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.V = append(m.V, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DU = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DV", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DV = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDepErr = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawHits = append(m.RawHits, &proio_model.Reference{})
			if err := m.RawHits[len(m.RawHits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitPlaneCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitPlaneCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitPlaneCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerHitPlane{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitZCylinder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitZCylinder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitZCylinder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Center = append(m.Center, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Center = append(m.Center, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Center", wireType)
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DRPhi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DRPhi = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DZ = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDepErr = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawHits = append(m.RawHits, &proio_model.Reference{})
			if err := m.RawHits[len(m.RawHits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitZCylinderCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitZCylinderCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitZCylinderCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerHitZCylinder{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Track) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Track: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Track: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chi2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Chi2 = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NDF", wireType)
			}
			m.NDF = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NDF |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEdx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DEdx = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEdxErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DEdxErr = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SubDetHits = append(m.SubDetHits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SubDetHits = append(m.SubDetHits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDetHits", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = append(m.States, &Track_TrackState{})
			if err := m.States[len(m.States)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hits = append(m.Hits, &proio_model.Reference{})
			if err := m.Hits[len(m.Hits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tracks = append(m.Tracks, &proio_model.Reference{})
			if err := m.Tracks[len(m.Tracks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Track_TrackState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loc", wireType)
			}
			m.Loc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field D0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.D0 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Phi = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Omega", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Omega = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z0 = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TanL", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TanL = float32(math.Float32frombits(v))
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Ref = append(m.Ref, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Ref = append(m.Ref, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Track{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimCalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimCalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contributions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contributions = append(m.Contributions, &SimCalorimeterHit_Contrib{})
			if err := m.Contributions[len(m.Contributions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHit_Contrib) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contrib: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contrib: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MCParticle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MCParticle == nil {
				m.MCParticle = &proio_model.Reference{}
			}
			if err := m.MCParticle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.StepPos = append(m.StepPos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.StepPos = append(m.StepPos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StepPos", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimCalorimeterHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimCalorimeterHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &SimCalorimeterHit{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amplitude", wireType)
			}
			m.Amplitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amplitude |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCalorimeterHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCalorimeterHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCalorimeterHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &RawCalorimeterHit{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EnergyErr = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Raw == nil {
				m.Raw = &proio_model.Reference{}
			}
			if err := m.Raw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalorimeterHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalorimeterHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalorimeterHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &CalorimeterHit{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EnergyErr = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.PosErr = append(m.PosErr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.PosErr = append(m.PosErr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PosErr", wireType)
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Theta", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Theta = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Phi = float32(math.Float32frombits(v))
		case 9:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.DirErr = append(m.DirErr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.DirErr = append(m.DirErr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DirErr", wireType)
			}
		case 10:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Shape = append(m.Shape, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Shape = append(m.Shape, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIDs = append(m.PIDs, &ParticleID{})
			if err := m.PIDs[len(m.PIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &proio_model.Reference{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hits = append(m.Hits, &proio_model.Reference{})
			if err := m.Hits[len(m.Hits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Weights = append(m.Weights, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Weights = append(m.Weights, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
		case 15:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.SubDetEnes = append(m.SubDetEnes, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.SubDetEnes = append(m.SubDetEnes, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDetEnes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Cluster{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Mass = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Charge = float32(math.Float32frombits(v))
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Ref = append(m.Ref, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Ref = append(m.Ref, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIDs = append(m.PIDs, &ParticleID{})
			if err := m.PIDs[len(m.PIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDUsed", wireType)
			}
			m.PIDUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PIDUsed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodnessOfPID", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GoodnessOfPID = float32(math.Float32frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recs = append(m.Recs, &proio_model.Reference{})
			if err := m.Recs[len(m.Recs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tracks = append(m.Tracks, &proio_model.Reference{})
			if err := m.Tracks[len(m.Tracks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &proio_model.Reference{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartVtx == nil {
				m.StartVtx = &proio_model.Reference{}
			}
			if err := m.StartVtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecParticleCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecParticleCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecParticleCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &RecParticle{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vertex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vertex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vertex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			m.Primary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Primary |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgType", wireType)
			}
			m.AlgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chi2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Chi2 = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prob", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Prob = float32(math.Float32frombits(v))
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Params = append(m.Params, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Params = append(m.Params, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecPart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecPart == nil {
				m.RecPart = &proio_model.Reference{}
			}
			if err := m.RecPart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VertexCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VertexCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VertexCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Vertex{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &proio_model.Reference{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &proio_model.Reference{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Weight = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &proio_model.Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Relation{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLcio(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLcio
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLcio(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLcio = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLcio   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proio/model/lcio/lcio.proto", fileDescriptorLcio) }

var fileDescriptorLcio = []byte{
	// 1927 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x4f, 0x6f, 0x24, 0x47,
	0x15, 0xa7, 0xba, 0x67, 0xa6, 0x67, 0xde, 0x78, 0xbc, 0xde, 0x4e, 0xf0, 0x76, 0x36, 0x1b, 0x63,
	0x06, 0x88, 0xac, 0x44, 0xcc, 0x3a, 0x0e, 0x0a, 0x10, 0x84, 0x10, 0xf1, 0x78, 0x89, 0xa5, 0x25,
	0x0c, 0xbd, 0x6b, 0x23, 0xed, 0xad, 0xdc, 0x5d, 0x9e, 0x69, 0xa5, 0xa7, 0xab, 0xe9, 0xae, 0x59,
	0xaf, 0x23, 0x24, 0x2e, 0x28, 0x5f, 0x00, 0x09, 0x88, 0x50, 0x90, 0x10, 0x42, 0x08, 0x71, 0xc8,
	0x81, 0xcf, 0x80, 0x84, 0xc4, 0x85, 0x03, 0x57, 0x24, 0xb4, 0xdc, 0x11, 0x5f, 0x00, 0x09, 0xd5,
	0xbf, 0xa9, 0xee, 0x9e, 0x1e, 0x7b, 0x14, 0x65, 0x76, 0x2f, 0x76, 0xbd, 0xaa, 0xd7, 0x3d, 0xaf,
	0x7e, 0xbf, 0xf7, 0xaf, 0xaa, 0xe1, 0xe5, 0x34, 0xa3, 0x11, 0xbd, 0x3b, 0xa5, 0x21, 0x89, 0xef,
	0xc6, 0x41, 0x44, 0xc5, 0x9f, 0x41, 0x9a, 0x51, 0x46, 0xdd, 0x2d, 0xb1, 0x38, 0x10, 0x8b, 0x03,
	0x3e, 0x7f, 0xfb, 0x56, 0x51, 0x5d, 0xae, 0x0a, 0xd5, 0xfe, 0xcf, 0x10, 0xc0, 0x08, 0x67, 0x2c,
	0x0a, 0x62, 0x72, 0x3c, 0x74, 0x77, 0x00, 0xe2, 0xe8, 0x7d, 0x12, 0x47, 0x13, 0x4a, 0x43, 0x0f,
	0xed, 0xa2, 0x3d, 0xcb, 0x2f, 0xcc, 0xb8, 0x2e, 0x34, 0xd8, 0x65, 0x4a, 0x3c, 0x6b, 0x17, 0xed,
	0x35, 0x7d, 0x31, 0x76, 0xb7, 0xc0, 0x1e, 0x0d, 0xbf, 0xe7, 0xd9, 0x62, 0x8a, 0x0f, 0x5d, 0x0f,
	0x1c, 0x1c, 0x8f, 0x1f, 0x72, 0xc5, 0x86, 0x98, 0xd5, 0xa2, 0xbb, 0x0d, 0xad, 0x14, 0x67, 0x78,
	0x9a, 0x7b, 0xcd, 0x5d, 0x7b, 0xcf, 0xf2, 0x95, 0xd4, 0xff, 0xd0, 0x06, 0xf8, 0xfe, 0xa1, 0x36,
	0xc4, 0xdd, 0x04, 0x2b, 0x92, 0x3f, 0xdf, 0xf3, 0xad, 0x28, 0x74, 0xf7, 0xc1, 0x49, 0x71, 0x46,
	0x12, 0x96, 0x7b, 0xd6, 0xae, 0xbd, 0xd7, 0x3d, 0xd8, 0x1e, 0x14, 0xb7, 0xe8, 0x93, 0x73, 0x92,
	0x91, 0x24, 0x20, 0xbe, 0x56, 0x73, 0x0f, 0xa0, 0x1d, 0x4c, 0xa2, 0x38, 0xcc, 0x48, 0xe2, 0xd9,
	0x57, 0x3e, 0x32, 0xd7, 0xd3, 0x1b, 0x69, 0x98, 0x8d, 0x6c, 0x43, 0xeb, 0x31, 0xc9, 0x18, 0x79,
	0x22, 0xcc, 0x45, 0xbe, 0x92, 0x04, 0x0c, 0xd1, 0x94, 0x78, 0x2d, 0x01, 0x90, 0x18, 0xbb, 0x1b,
	0x80, 0x52, 0xcf, 0x11, 0x6a, 0x28, 0xe5, 0x1a, 0x53, 0x9c, 0xe7, 0x5e, 0x7b, 0x17, 0xed, 0x21,
	0x5f, 0x8c, 0xf9, 0xdb, 0x82, 0x09, 0xce, 0xc6, 0xc4, 0xeb, 0x88, 0xe7, 0x94, 0xe4, 0xde, 0x81,
	0xce, 0xe8, 0x28, 0x09, 0x47, 0x34, 0x4a, 0x98, 0x07, 0xe2, 0x0d, 0x66, 0x82, 0xbf, 0x29, 0x4f,
	0xa3, 0xc4, 0xeb, 0x0a, 0xc0, 0xc4, 0x98, 0x3f, 0x11, 0xd0, 0x98, 0x66, 0xf7, 0x62, 0x7a, 0xe1,
	0x6d, 0xec, 0xda, 0x7b, 0x4d, 0xdf, 0x4c, 0xf0, 0xd5, 0x31, 0x49, 0x1e, 0x30, 0xcc, 0x66, 0xb9,
	0xd7, 0x13, 0xbb, 0x31, 0x13, 0x7c, 0x35, 0x8f, 0xa6, 0x6a, 0x75, 0x53, 0x40, 0x6c, 0x26, 0xfa,
	0xbf, 0x45, 0xf0, 0xa2, 0x21, 0xe2, 0x90, 0xc6, 0x31, 0x09, 0x58, 0x44, 0x93, 0x05, 0x4a, 0x5e,
	0x84, 0xe6, 0x79, 0x8c, 0xc7, 0xb9, 0x70, 0x85, 0x9e, 0x2f, 0x05, 0xf7, 0xf5, 0x39, 0xbf, 0xdc,
	0x1d, 0xba, 0x07, 0x2f, 0x94, 0x40, 0x1f, 0x89, 0x25, 0x4d, 0xba, 0xfb, 0x16, 0x38, 0x24, 0x61,
	0x59, 0x44, 0x72, 0xaf, 0x21, 0x28, 0xba, 0x33, 0xa8, 0x3a, 0xee, 0xc0, 0xd8, 0xe2, 0x6b, 0xe5,
	0xfe, 0xff, 0x10, 0xf4, 0x1e, 0x44, 0xd3, 0x87, 0x19, 0x0e, 0xde, 0x27, 0xd9, 0xbb, 0x11, 0x5b,
	0x30, 0xce, 0x03, 0x27, 0x20, 0x71, 0x7c, 0x3c, 0xdc, 0x57, 0x9e, 0xaa, 0x45, 0xb3, 0xf2, 0x86,
	0x72, 0x58, 0x2d, 0x72, 0xf6, 0x53, 0x2a, 0x2d, 0x41, 0x3e, 0x1f, 0x72, 0xe4, 0x8f, 0x86, 0x24,
	0xf5, 0x9a, 0x92, 0x65, 0x3e, 0xae, 0x65, 0xfe, 0x55, 0xb0, 0xa6, 0x81, 0xe7, 0x88, 0x0d, 0x2f,
	0xf3, 0x32, 0x6b, 0x1a, 0x48, 0x0f, 0x69, 0x0b, 0x1a, 0x51, 0xca, 0x43, 0x2d, 0xc5, 0x6c, 0x72,
	0x9f, 0x24, 0x63, 0x36, 0x51, 0x1e, 0x51, 0x98, 0xe1, 0x96, 0xfe, 0x78, 0x86, 0xe3, 0x88, 0x5d,
	0x7a, 0x20, 0x2d, 0x55, 0x62, 0xff, 0x0f, 0x08, 0x6e, 0x95, 0xf6, 0xbf, 0x5e, 0x9a, 0xbe, 0x59,
	0xa5, 0xe9, 0x0b, 0x8b, 0x34, 0x95, 0xcc, 0x31, 0x4c, 0xfd, 0x04, 0x36, 0xd5, 0xb4, 0x8f, 0x2f,
	0x86, 0x98, 0xe1, 0xcf, 0x84, 0x29, 0xcd, 0x41, 0x43, 0x25, 0x21, 0xce, 0x81, 0x0b, 0x8d, 0xef,
	0x0e, 0x0f, 0x65, 0x5a, 0xe9, 0xf9, 0x62, 0xdc, 0xff, 0x23, 0x02, 0xaf, 0xfc, 0xf3, 0xeb, 0x05,
	0xea, 0xed, 0x2a, 0x50, 0xbb, 0x8b, 0x40, 0x95, 0xed, 0x31, 0x48, 0xfd, 0x14, 0xba, 0x6a, 0x69,
	0x2d, 0x30, 0x69, 0x57, 0xe5, 0xda, 0x22, 0xe9, 0xe8, 0x04, 0xac, 0xc5, 0xfe, 0xef, 0x10, 0x7c,
	0xbe, 0x60, 0xc1, 0x7a, 0x91, 0xfa, 0x7a, 0x15, 0xa9, 0x57, 0x96, 0x22, 0x55, 0x86, 0xe9, 0x17,
	0x16, 0xc0, 0x67, 0x1c, 0xf7, 0xba, 0xa4, 0x35, 0xca, 0x25, 0x8d, 0xe7, 0x82, 0xa6, 0xc9, 0x05,
	0x5b, 0x60, 0x07, 0xf4, 0xb1, 0xd7, 0x92, 0x33, 0x01, 0x7d, 0x3c, 0xcf, 0x0e, 0x4e, 0x21, 0x3b,
	0x78, 0xe0, 0xf0, 0xff, 0x47, 0x59, 0x26, 0x12, 0xbf, 0xe5, 0x6b, 0x71, 0x4e, 0x46, 0xa7, 0x4c,
	0x46, 0x7d, 0x84, 0xf3, 0x7a, 0x97, 0xe1, 0x8b, 0x77, 0x23, 0x96, 0x8b, 0xb4, 0x7f, 0x45, 0xbd,
	0x53, 0x6a, 0x22, 0x6f, 0x3f, 0xab, 0x84, 0xb0, 0x4a, 0xde, 0xae, 0xcb, 0x06, 0xff, 0x40, 0xb0,
	0xa1, 0xe6, 0x47, 0xb3, 0x38, 0x27, 0x6b, 0xf3, 0x72, 0x53, 0x68, 0x9b, 0xa5, 0x42, 0x5b, 0x20,
	0xd1, 0x92, 0x24, 0x16, 0x28, 0x70, 0xca, 0x14, 0xec, 0x81, 0xfd, 0x70, 0x74, 0x28, 0x68, 0x5c,
	0x0e, 0x3f, 0x57, 0xe9, 0xff, 0x1e, 0xc1, 0x76, 0x71, 0x5b, 0xeb, 0x05, 0xff, 0x1b, 0x55, 0xf0,
	0x77, 0x96, 0x82, 0x2f, 0xac, 0x31, 0xf0, 0xff, 0xc5, 0x82, 0x1b, 0x86, 0x96, 0x51, 0x8c, 0x13,
	0xf2, 0x0c, 0x03, 0x68, 0x03, 0xd0, 0x89, 0x42, 0x1e, 0x9d, 0x70, 0xe9, 0x54, 0x34, 0x4b, 0x96,
	0x8f, 0x4e, 0xb9, 0x15, 0xe1, 0x89, 0x8a, 0x18, 0x2b, 0x3c, 0x11, 0xf2, 0xa9, 0x0a, 0x15, 0x2b,
	0x3c, 0x9d, 0x87, 0x1a, 0xd4, 0x87, 0x5a, 0xb7, 0x3e, 0xd4, 0x36, 0xea, 0x43, 0xad, 0xb7, 0x34,
	0xd4, 0x36, 0x57, 0x0b, 0xb5, 0x3f, 0x21, 0x78, 0xa9, 0x82, 0xe3, 0x7a, 0x29, 0xff, 0x56, 0x95,
	0xf2, 0x2f, 0x5e, 0x15, 0x6f, 0xc2, 0x20, 0xc3, 0xfa, 0xdf, 0x2c, 0x78, 0xc1, 0x2c, 0x3e, 0x3a,
	0xbc, 0x8c, 0xa3, 0x24, 0x24, 0xd9, 0x33, 0x64, 0x9e, 0x47, 0x23, 0x49, 0x18, 0xc9, 0x14, 0xfd,
	0x4a, 0xe2, 0xc8, 0x84, 0xfe, 0x68, 0x12, 0xa9, 0x0c, 0x2a, 0x05, 0xc1, 0xfd, 0xa3, 0xb9, 0x2f,
	0x3c, 0x9a, 0x73, 0xdf, 0xa9, 0xe7, 0x1e, 0xea, 0xb9, 0xef, 0xd6, 0x73, 0xbf, 0xb1, 0x94, 0xfb,
	0xde, 0x6a, 0xdc, 0xff, 0x19, 0xc1, 0x2b, 0x35, 0x68, 0xae, 0x97, 0xff, 0xef, 0x54, 0xf9, 0xff,
	0xca, 0x55, 0xfc, 0xcf, 0x8d, 0x32, 0x3e, 0xf0, 0x5f, 0x1b, 0x9a, 0x42, 0x61, 0xc1, 0xba, 0xba,
	0xf3, 0x9c, 0x0b, 0x8d, 0x60, 0x12, 0x1d, 0x08, 0xcb, 0x2c, 0x5f, 0x8c, 0x39, 0xab, 0xef, 0x0d,
	0xef, 0xe9, 0xa3, 0xd1, 0x7b, 0xc3, 0x7b, 0x5c, 0x2b, 0x3c, 0x0a, 0x9f, 0xe8, 0xe6, 0x98, 0x8f,
	0x39, 0xd2, 0xfc, 0x3f, 0xe7, 0x45, 0xf6, 0xc7, 0x5a, 0xe4, 0x3e, 0x90, 0xe1, 0x30, 0x9a, 0xe5,
	0x8a, 0x6c, 0x25, 0xf1, 0x26, 0x38, 0x9f, 0x9d, 0x0d, 0x09, 0x13, 0x24, 0xb4, 0xc5, 0x49, 0xa6,
	0x30, 0xe3, 0xbe, 0x0d, 0xad, 0x9c, 0x61, 0x46, 0x72, 0xaf, 0x23, 0x76, 0xde, 0x5f, 0xb2, 0x73,
	0xf9, 0x97, 0x9f, 0x61, 0x88, 0xaf, 0x9e, 0x70, 0x5f, 0x83, 0xc6, 0x84, 0xbf, 0x15, 0xae, 0xa4,
	0x56, 0xe8, 0xb8, 0x03, 0x68, 0x31, 0xfe, 0x86, 0xeb, 0xea, 0xad, 0xd2, 0xba, 0xfd, 0x1b, 0xa4,
	0xfa, 0x10, 0xf1, 0x93, 0x1c, 0x9e, 0x98, 0x06, 0x02, 0xd7, 0xa6, 0xcf, 0x87, 0xc2, 0x8d, 0x65,
	0x24, 0x71, 0x37, 0xde, 0x17, 0x61, 0x31, 0x89, 0x14, 0xa6, 0x7c, 0xc8, 0x1d, 0x83, 0x4e, 0xc9,
	0x18, 0xab, 0xca, 0x25, 0x05, 0xfe, 0xdc, 0x07, 0xfb, 0x0a, 0x54, 0xeb, 0x83, 0x7d, 0x41, 0x10,
	0x4e, 0xee, 0xcf, 0xcf, 0x1b, 0x38, 0xb9, 0xaf, 0xcb, 0x98, 0x63, 0xca, 0xd8, 0x16, 0xd8, 0x19,
	0x39, 0x57, 0x67, 0x0b, 0x3e, 0xec, 0xff, 0x12, 0xa9, 0x64, 0xbf, 0x5e, 0xd7, 0x7c, 0xa3, 0xea,
	0x9a, 0xb7, 0x96, 0x10, 0x64, 0x9c, 0xf1, 0x63, 0x1b, 0x6e, 0x3e, 0x88, 0xa6, 0x87, 0x38, 0xa6,
	0x59, 0x34, 0x25, 0xac, 0xbe, 0x93, 0x33, 0x56, 0x58, 0xd7, 0x5b, 0x51, 0xc8, 0x5d, 0xf6, 0xd2,
	0xdc, 0xd5, 0x28, 0xe7, 0xae, 0x6d, 0x68, 0x91, 0x84, 0x64, 0xe3, 0x4b, 0xdd, 0x23, 0x48, 0x49,
	0xe7, 0x2f, 0xd5, 0x23, 0xf0, 0xfc, 0xf5, 0x43, 0xe8, 0x05, 0x94, 0x1b, 0x7f, 0x36, 0xe3, 0x30,
	0xe6, 0x02, 0xf8, 0xee, 0xc1, 0xeb, 0xb5, 0xa7, 0xa0, 0xf2, 0xb6, 0x06, 0x87, 0xf2, 0x41, 0xbf,
	0xfc, 0x86, 0xdb, 0x1f, 0x21, 0x70, 0xd4, 0x92, 0xfb, 0x56, 0xf1, 0xe6, 0x43, 0x20, 0xb0, 0xdc,
	0xfd, 0x8a, 0x77, 0x24, 0x66, 0x03, 0x56, 0x69, 0x03, 0x3a, 0x05, 0xda, 0x85, 0x14, 0xb8, 0x78,
	0xb3, 0xe1, 0x81, 0x93, 0x33, 0x92, 0x8e, 0xe8, 0xfc, 0x20, 0xa0, 0xc4, 0xfe, 0x27, 0x08, 0x5e,
	0x5e, 0xd8, 0xc8, 0x7a, 0xbd, 0xe8, 0xdb, 0x55, 0x2f, 0xfa, 0xd2, 0x0a, 0xd8, 0x1a, 0x8f, 0xfa,
	0x39, 0x82, 0x9b, 0x3e, 0xbe, 0xb8, 0xc6, 0xa3, 0x3e, 0x4d, 0x81, 0xbb, 0x03, 0x1d, 0x3c, 0x4d,
	0xe3, 0x88, 0xcd, 0x42, 0x5d, 0xe5, 0xcc, 0x04, 0x5f, 0xe5, 0xe8, 0x3e, 0x60, 0x78, 0x2a, 0x2f,
	0x09, 0x9a, 0xbe, 0x99, 0x10, 0x38, 0x2e, 0x58, 0xf5, 0xfc, 0x71, 0x5c, 0x30, 0xc9, 0xe0, 0xf8,
	0x1f, 0x04, 0x9b, 0x6b, 0x00, 0xd1, 0x38, 0x6a, 0xa3, 0xe4, 0xa8, 0x77, 0xa0, 0x23, 0x47, 0xbc,
	0x5e, 0xc8, 0x20, 0x34, 0x13, 0xb5, 0x17, 0x2d, 0x2a, 0x36, 0x1d, 0x13, 0x9b, 0xba, 0x7e, 0xb5,
	0x0b, 0xf5, 0x6b, 0x0f, 0xec, 0x0c, 0x5f, 0x88, 0x86, 0xe1, 0x8a, 0xce, 0x3d, 0xc3, 0x17, 0xe2,
	0x82, 0xe0, 0x59, 0xf2, 0xb3, 0xca, 0x05, 0xc1, 0x32, 0x72, 0x3e, 0xb1, 0xc1, 0x39, 0x8c, 0x67,
	0x39, 0xab, 0xe9, 0xdd, 0xea, 0xaa, 0xb8, 0x41, 0xdd, 0x5e, 0x8e, 0x7a, 0xa3, 0x8a, 0x7a, 0xa1,
	0x7b, 0xb3, 0xe6, 0xdd, 0x5b, 0x4a, 0x73, 0x59, 0xd2, 0xe5, 0x8d, 0xad, 0x90, 0x38, 0x1c, 0x6c,
	0x42, 0x18, 0xd6, 0xdd, 0x9b, 0x10, 0x74, 0x99, 0x6b, 0x9b, 0x32, 0xb7, 0x0d, 0xad, 0x30, 0xca,
	0xf8, 0xf3, 0x1d, 0xf9, 0xbc, 0x94, 0xf8, 0xf3, 0xf9, 0x04, 0xa7, 0x44, 0x94, 0x67, 0xcb, 0x97,
	0x82, 0xbb, 0x0f, 0x8d, 0xd1, 0xf1, 0x50, 0x57, 0xe1, 0x9a, 0x73, 0xa5, 0xb9, 0xab, 0xf6, 0x85,
	0xa6, 0xb8, 0xe8, 0x95, 0xb0, 0xe4, 0xe2, 0x26, 0xf4, 0xaa, 0x8b, 0x5e, 0xa5, 0x37, 0xef, 0x0c,
	0x7a, 0x2b, 0x74, 0x06, 0x1e, 0x38, 0x17, 0x24, 0x1a, 0x4f, 0xd4, 0xf9, 0xc0, 0xf2, 0xb5, 0x68,
	0x7a, 0x97, 0xa3, 0x84, 0xe4, 0xde, 0x0d, 0xb1, 0x58, 0x98, 0xe9, 0xff, 0x1a, 0xc1, 0x4d, 0xc5,
	0xd8, 0x7a, 0xdd, 0xea, 0xcd, 0xaa, 0x5b, 0xbd, 0x54, 0xe3, 0x56, 0xd2, 0x10, 0xe3, 0x4f, 0xff,
	0xb4, 0xa1, 0xeb, 0x93, 0x60, 0xe9, 0x95, 0x7b, 0x9d, 0x4f, 0x89, 0x0b, 0x4c, 0x5b, 0x5f, 0x60,
	0x2e, 0x8b, 0x6b, 0xd5, 0x9e, 0x34, 0x4d, 0x7b, 0xa2, 0x2f, 0xc3, 0x55, 0x2c, 0x57, 0x2e, 0xc3,
	0x9d, 0xea, 0x19, 0xbd, 0xdc, 0xca, 0xcc, 0x7d, 0xa2, 0xb3, 0xb2, 0x4f, 0x78, 0xe0, 0x8c, 0x8e,
	0x87, 0x27, 0x39, 0x09, 0xf5, 0xc5, 0x8a, 0x12, 0xdd, 0x2f, 0x43, 0x6f, 0x4c, 0x69, 0x98, 0x90,
	0x3c, 0xff, 0xc1, 0xf9, 0xe8, 0x78, 0xa8, 0x0e, 0x0a, 0xe5, 0x49, 0xee, 0x1f, 0x19, 0x09, 0xae,
	0xf3, 0x27, 0xa1, 0x53, 0xe8, 0x1c, 0x7b, 0xab, 0x74, 0x8e, 0x25, 0x7f, 0xdd, 0x5c, 0xd1, 0x5f,
	0x0f, 0xa0, 0x9d, 0x33, 0x9c, 0xb1, 0x53, 0xf6, 0xc4, 0xbb, 0x71, 0x65, 0x5a, 0x9b, 0xeb, 0x89,
	0xfb, 0xbc, 0x02, 0xbf, 0xcf, 0xff, 0x3e, 0xaf, 0x60, 0x8c, 0xf1, 0xc2, 0xa7, 0x08, 0x5a, 0xa7,
	0xf2, 0x9b, 0x4a, 0x4d, 0xa9, 0x49, 0xb3, 0x68, 0x8a, 0xb3, 0x4b, 0x5d, 0x6a, 0x94, 0x58, 0xfc,
	0xbc, 0x64, 0x97, 0x3f, 0x2f, 0xe9, 0xa3, 0x4b, 0xa3, 0x70, 0x74, 0x71, 0xa1, 0x91, 0x66, 0xf4,
	0x4c, 0x1f, 0x54, 0xf8, 0xb8, 0xa6, 0xc9, 0x5b, 0xec, 0xa9, 0xcd, 0xa7, 0xaa, 0x76, 0xf1, 0x53,
	0x95, 0x38, 0x34, 0xca, 0xad, 0x5c, 0x53, 0x62, 0xb4, 0x5a, 0xff, 0x23, 0x04, 0x5b, 0x72, 0x93,
	0xeb, 0x65, 0xe1, 0xa0, 0xca, 0x82, 0xb7, 0xc8, 0x82, 0xb4, 0xc3, 0x10, 0xf0, 0x21, 0x82, 0xb6,
	0x4f, 0x62, 0x5c, 0x6b, 0xd3, 0x6b, 0xd0, 0x38, 0xcf, 0xe8, 0x54, 0xb5, 0xe0, 0x4b, 0xe3, 0x80,
	0xeb, 0xb8, 0xaf, 0x82, 0xc5, 0xa8, 0xb2, 0x72, 0xe9, 0x47, 0x10, 0x46, 0x39, 0xac, 0x32, 0x81,
	0xea, 0xac, 0x21, 0xa5, 0xfe, 0xc7, 0x08, 0x5c, 0x6d, 0xc8, 0x7a, 0x61, 0xfa, 0x5a, 0x15, 0xa6,
	0xdb, 0x75, 0xce, 0x2a, 0x2d, 0x99, 0x03, 0xf5, 0xce, 0x8f, 0xfe, 0xfa, 0x74, 0x07, 0xfd, 0xfd,
	0xe9, 0x0e, 0xfa, 0xd7, 0xd3, 0x1d, 0xf4, 0xab, 0x7f, 0xef, 0x7c, 0x0e, 0xba, 0x85, 0xa7, 0xde,
	0x69, 0xdc, 0x0f, 0x22, 0xfa, 0xe8, 0x60, 0x1c, 0xb1, 0xc9, 0xec, 0x6c, 0x10, 0xd0, 0xe9, 0xdd,
	0x90, 0x04, 0xd1, 0x19, 0x89, 0x03, 0x4a, 0x53, 0x92, 0xc9, 0x6f, 0xae, 0x77, 0xc7, 0xf4, 0xab,
	0xd5, 0xef, 0xb6, 0x67, 0x2d, 0xf1, 0x21, 0xf6, 0xcd, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x63,
	0x73, 0xee, 0x5a, 0xd2, 0x1d, 0x00, 0x00,
}

// Extra generated functions for compliance with Message and Collection interfaces

func (c *MCParticleCollection) SetId(id uint32) {
	c.Id = id
}

func (c *MCParticleCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *MCParticleCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *SimTrackerHitCollection) SetId(id uint32) {
	c.Id = id
}

func (c *SimTrackerHitCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *SimTrackerHitCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerRawDataCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerRawDataCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerRawDataCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerDataCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerDataCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerDataCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerHitCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerHitCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerHitCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerPulseCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerPulseCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerPulseCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerHitPlaneCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerHitPlaneCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerHitPlaneCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerHitZCylinderCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerHitZCylinderCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerHitZCylinderCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *SimCalorimeterHitCollection) SetId(id uint32) {
	c.Id = id
}

func (c *SimCalorimeterHitCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *SimCalorimeterHitCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *RawCalorimeterHitCollection) SetId(id uint32) {
	c.Id = id
}

func (c *RawCalorimeterHitCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *RawCalorimeterHitCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *CalorimeterHitCollection) SetId(id uint32) {
	c.Id = id
}

func (c *CalorimeterHitCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *CalorimeterHitCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *ClusterCollection) SetId(id uint32) {
	c.Id = id
}

func (c *ClusterCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *ClusterCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *RecParticleCollection) SetId(id uint32) {
	c.Id = id
}

func (c *RecParticleCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *RecParticleCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *VertexCollection) SetId(id uint32) {
	c.Id = id
}

func (c *VertexCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *VertexCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *RelationCollection) SetId(id uint32) {
	c.Id = id
}

func (c *RelationCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *RelationCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (m *MCParticle) SetId(id uint32) {
	m.Id = id
}

func (m *SimTrackerHit) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerRawData) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerData) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerHit) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerPulse) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerHitPlane) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerHitZCylinder) SetId(id uint32) {
	m.Id = id
}

func (m *Track) SetId(id uint32) {
	m.Id = id
}

func (m *SimCalorimeterHit) SetId(id uint32) {
	m.Id = id
}

func (m *RawCalorimeterHit) SetId(id uint32) {
	m.Id = id
}

func (m *CalorimeterHit) SetId(id uint32) {
	m.Id = id
}

func (m *Cluster) SetId(id uint32) {
	m.Id = id
}

func (m *RecParticle) SetId(id uint32) {
	m.Id = id
}

func (m *Vertex) SetId(id uint32) {
	m.Id = id
}

func (m *Relation) SetId(id uint32) {
	m.Id = id
}
