// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: eicio.proto

/*
	Package eicio is a generated protocol buffer package.

	It is generated from these files:
		eicio.proto

	It has these top-level messages:
		EventHeader
		Params
		Reference
		ParticleID
		MCParticle
		MCParticleCollection
		SimTrackerHit
		SimTrackerHitCollection
		TrackerRawData
		TrackerRawDataCollection
		TrackerData
		TrackerDataCollection
		TrackerHit
		TrackerHitCollection
		TrackerPulse
		TrackerPulseCollection
		TrackerHitPlane
		TrackerHitPlaneCollection
		TrackerHitZCylinder
		TrackerHitZCylinderCollection
		Track
		TrackCollection
		SimCalorimeterHit
		SimCalorimeterHitCollection
		RawCalorimeterHit
		RawCalorimeterHitCollection
		CalorimeterHit
		CalorimeterHitCollection
		Cluster
		ClusterCollection
		RecParticle
		RecParticleCollection
		Vertex
		VertexCollection
		Relation
		RelationCollection
*/
package eicio

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type EventHeader_CollectionHeader_Type int32

const (
	EventHeader_CollectionHeader_NONE                EventHeader_CollectionHeader_Type = 0
	EventHeader_CollectionHeader_MCParticle          EventHeader_CollectionHeader_Type = 1
	EventHeader_CollectionHeader_SimTrackerHit       EventHeader_CollectionHeader_Type = 2
	EventHeader_CollectionHeader_TrackerData         EventHeader_CollectionHeader_Type = 3
	EventHeader_CollectionHeader_TrackerRawData      EventHeader_CollectionHeader_Type = 4
	EventHeader_CollectionHeader_TrackerHit          EventHeader_CollectionHeader_Type = 5
	EventHeader_CollectionHeader_TrackerPulse        EventHeader_CollectionHeader_Type = 6
	EventHeader_CollectionHeader_TrackerHitPlane     EventHeader_CollectionHeader_Type = 7
	EventHeader_CollectionHeader_TrackerHitZCylinder EventHeader_CollectionHeader_Type = 8
	EventHeader_CollectionHeader_Track               EventHeader_CollectionHeader_Type = 9
	EventHeader_CollectionHeader_SimCalorimeterHit   EventHeader_CollectionHeader_Type = 10
	EventHeader_CollectionHeader_RawCalorimeterHit   EventHeader_CollectionHeader_Type = 11
	EventHeader_CollectionHeader_CalorimeterHit      EventHeader_CollectionHeader_Type = 12
	EventHeader_CollectionHeader_Cluster             EventHeader_CollectionHeader_Type = 13
	EventHeader_CollectionHeader_RecParticle         EventHeader_CollectionHeader_Type = 14
	EventHeader_CollectionHeader_Vertex              EventHeader_CollectionHeader_Type = 15
	EventHeader_CollectionHeader_Relation            EventHeader_CollectionHeader_Type = 16
)

var EventHeader_CollectionHeader_Type_name = map[int32]string{
	0:  "NONE",
	1:  "MCParticle",
	2:  "SimTrackerHit",
	3:  "TrackerData",
	4:  "TrackerRawData",
	5:  "TrackerHit",
	6:  "TrackerPulse",
	7:  "TrackerHitPlane",
	8:  "TrackerHitZCylinder",
	9:  "Track",
	10: "SimCalorimeterHit",
	11: "RawCalorimeterHit",
	12: "CalorimeterHit",
	13: "Cluster",
	14: "RecParticle",
	15: "Vertex",
	16: "Relation",
}
var EventHeader_CollectionHeader_Type_value = map[string]int32{
	"NONE":                0,
	"MCParticle":          1,
	"SimTrackerHit":       2,
	"TrackerData":         3,
	"TrackerRawData":      4,
	"TrackerHit":          5,
	"TrackerPulse":        6,
	"TrackerHitPlane":     7,
	"TrackerHitZCylinder": 8,
	"Track":               9,
	"SimCalorimeterHit":   10,
	"RawCalorimeterHit":   11,
	"CalorimeterHit":      12,
	"Cluster":             13,
	"RecParticle":         14,
	"Vertex":              15,
	"Relation":            16,
}

func (x EventHeader_CollectionHeader_Type) String() string {
	return proto.EnumName(EventHeader_CollectionHeader_Type_name, int32(x))
}
func (EventHeader_CollectionHeader_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorEicio, []int{0, 0, 0}
}

type EventHeader struct {
	Version     uint32                          `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	RunNumber   uint64                          `protobuf:"varint,2,opt,name=runNumber,proto3" json:"runNumber,omitempty"`
	EventNumber uint64                          `protobuf:"varint,3,opt,name=eventNumber,proto3" json:"eventNumber,omitempty"`
	TimeStamp   uint64                          `protobuf:"varint,4,opt,name=timeStamp,proto3" json:"timeStamp,omitempty"`
	Detector    string                          `protobuf:"bytes,5,opt,name=detector,proto3" json:"detector,omitempty"`
	Params      *Params                         `protobuf:"bytes,6,opt,name=params" json:"params,omitempty"`
	Collection  []*EventHeader_CollectionHeader `protobuf:"bytes,7,rep,name=collection" json:"collection,omitempty"`
	Description string                          `protobuf:"bytes,16,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *EventHeader) Reset()                    { *m = EventHeader{} }
func (m *EventHeader) String() string            { return proto.CompactTextString(m) }
func (*EventHeader) ProtoMessage()               {}
func (*EventHeader) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{0} }

func (m *EventHeader) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *EventHeader) GetRunNumber() uint64 {
	if m != nil {
		return m.RunNumber
	}
	return 0
}

func (m *EventHeader) GetEventNumber() uint64 {
	if m != nil {
		return m.EventNumber
	}
	return 0
}

func (m *EventHeader) GetTimeStamp() uint64 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

func (m *EventHeader) GetDetector() string {
	if m != nil {
		return m.Detector
	}
	return ""
}

func (m *EventHeader) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *EventHeader) GetCollection() []*EventHeader_CollectionHeader {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *EventHeader) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type EventHeader_CollectionHeader struct {
	Type        EventHeader_CollectionHeader_Type `protobuf:"varint,1,opt,name=type,proto3,enum=eicio.EventHeader_CollectionHeader_Type" json:"type,omitempty"`
	Name        string                            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	PayloadSize uint32                            `protobuf:"varint,3,opt,name=payloadSize,proto3" json:"payloadSize,omitempty"`
}

func (m *EventHeader_CollectionHeader) Reset()         { *m = EventHeader_CollectionHeader{} }
func (m *EventHeader_CollectionHeader) String() string { return proto.CompactTextString(m) }
func (*EventHeader_CollectionHeader) ProtoMessage()    {}
func (*EventHeader_CollectionHeader) Descriptor() ([]byte, []int) {
	return fileDescriptorEicio, []int{0, 0}
}

func (m *EventHeader_CollectionHeader) GetType() EventHeader_CollectionHeader_Type {
	if m != nil {
		return m.Type
	}
	return EventHeader_CollectionHeader_NONE
}

func (m *EventHeader_CollectionHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventHeader_CollectionHeader) GetPayloadSize() uint32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

type Params struct {
	Ints    map[string]int32   `protobuf:"bytes,1,rep,name=ints" json:"ints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Floats  map[string]float32 `protobuf:"bytes,2,rep,name=floats" json:"floats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Strings map[string]string  `protobuf:"bytes,3,rep,name=strings" json:"strings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Params) Reset()                    { *m = Params{} }
func (m *Params) String() string            { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()               {}
func (*Params) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{1} }

func (m *Params) GetInts() map[string]int32 {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *Params) GetFloats() map[string]float32 {
	if m != nil {
		return m.Floats
	}
	return nil
}

func (m *Params) GetStrings() map[string]string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type Reference struct {
	CollID  uint32 `protobuf:"varint,1,opt,name=collID,proto3" json:"collID,omitempty"`
	EntryID uint32 `protobuf:"varint,2,opt,name=entryID,proto3" json:"entryID,omitempty"`
}

func (m *Reference) Reset()                    { *m = Reference{} }
func (m *Reference) String() string            { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()               {}
func (*Reference) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{2} }

func (m *Reference) GetCollID() uint32 {
	if m != nil {
		return m.CollID
	}
	return 0
}

func (m *Reference) GetEntryID() uint32 {
	if m != nil {
		return m.EntryID
	}
	return 0
}

type ParticleID struct {
	Likelihood float32   `protobuf:"fixed32,1,opt,name=likelihood,proto3" json:"likelihood,omitempty"`
	Type       int32     `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	PDG        int32     `protobuf:"varint,3,opt,name=PDG,proto3" json:"PDG,omitempty"`
	AlgType    int32     `protobuf:"varint,4,opt,name=algType,proto3" json:"algType,omitempty"`
	Params     []float32 `protobuf:"fixed32,5,rep,packed,name=params" json:"params,omitempty"`
}

func (m *ParticleID) Reset()                    { *m = ParticleID{} }
func (m *ParticleID) String() string            { return proto.CompactTextString(m) }
func (*ParticleID) ProtoMessage()               {}
func (*ParticleID) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{3} }

func (m *ParticleID) GetLikelihood() float32 {
	if m != nil {
		return m.Likelihood
	}
	return 0
}

func (m *ParticleID) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ParticleID) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *ParticleID) GetAlgType() int32 {
	if m != nil {
		return m.AlgType
	}
	return 0
}

func (m *ParticleID) GetParams() []float32 {
	if m != nil {
		return m.Params
	}
	return nil
}

type MCParticle struct {
	Parents   []int32   `protobuf:"varint,1,rep,packed,name=parents" json:"parents,omitempty"`
	Children  []int32   `protobuf:"varint,2,rep,packed,name=children" json:"children,omitempty"`
	PDG       int32     `protobuf:"varint,3,opt,name=PDG,proto3" json:"PDG,omitempty"`
	Vertex    []float64 `protobuf:"fixed64,4,rep,packed,name=vertex" json:"vertex,omitempty"`
	Time      float32   `protobuf:"fixed32,5,opt,name=time,proto3" json:"time,omitempty"`
	P         []float64 `protobuf:"fixed64,6,rep,packed,name=p" json:"p,omitempty"`
	Mass      float64   `protobuf:"fixed64,7,opt,name=mass,proto3" json:"mass,omitempty"`
	Charge    float32   `protobuf:"fixed32,8,opt,name=charge,proto3" json:"charge,omitempty"`
	PEndPoint []float64 `protobuf:"fixed64,9,rep,packed,name=PEndPoint" json:"PEndPoint,omitempty"`
	Spin      []float32 `protobuf:"fixed32,10,rep,packed,name=spin" json:"spin,omitempty"`
	ColorFlow []int32   `protobuf:"varint,11,rep,packed,name=colorFlow" json:"colorFlow,omitempty"`
	GenStatus int32     `protobuf:"varint,12,opt,name=genStatus,proto3" json:"genStatus,omitempty"`
	SimStatus uint32    `protobuf:"varint,13,opt,name=simStatus,proto3" json:"simStatus,omitempty"`
}

func (m *MCParticle) Reset()                    { *m = MCParticle{} }
func (m *MCParticle) String() string            { return proto.CompactTextString(m) }
func (*MCParticle) ProtoMessage()               {}
func (*MCParticle) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{4} }

func (m *MCParticle) GetParents() []int32 {
	if m != nil {
		return m.Parents
	}
	return nil
}

func (m *MCParticle) GetChildren() []int32 {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *MCParticle) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *MCParticle) GetVertex() []float64 {
	if m != nil {
		return m.Vertex
	}
	return nil
}

func (m *MCParticle) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *MCParticle) GetP() []float64 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *MCParticle) GetMass() float64 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *MCParticle) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *MCParticle) GetPEndPoint() []float64 {
	if m != nil {
		return m.PEndPoint
	}
	return nil
}

func (m *MCParticle) GetSpin() []float32 {
	if m != nil {
		return m.Spin
	}
	return nil
}

func (m *MCParticle) GetColorFlow() []int32 {
	if m != nil {
		return m.ColorFlow
	}
	return nil
}

func (m *MCParticle) GetGenStatus() int32 {
	if m != nil {
		return m.GenStatus
	}
	return 0
}

func (m *MCParticle) GetSimStatus() uint32 {
	if m != nil {
		return m.SimStatus
	}
	return 0
}

type MCParticleCollection struct {
	Flags    int32         `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params   *Params       `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Particle []*MCParticle `protobuf:"bytes,3,rep,name=particle" json:"particle,omitempty"`
}

func (m *MCParticleCollection) Reset()                    { *m = MCParticleCollection{} }
func (m *MCParticleCollection) String() string            { return proto.CompactTextString(m) }
func (*MCParticleCollection) ProtoMessage()               {}
func (*MCParticleCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{5} }

func (m *MCParticleCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *MCParticleCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *MCParticleCollection) GetParticle() []*MCParticle {
	if m != nil {
		return m.Particle
	}
	return nil
}

type SimTrackerHit struct {
	CellID0    int32      `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1    int32      `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Pos        []float64  `protobuf:"fixed64,3,rep,packed,name=pos" json:"pos,omitempty"`
	EDep       float32    `protobuf:"fixed32,4,opt,name=EDep,proto3" json:"EDep,omitempty"`
	Time       float32    `protobuf:"fixed32,5,opt,name=time,proto3" json:"time,omitempty"`
	Mc         *Reference `protobuf:"bytes,6,opt,name=mc" json:"mc,omitempty"`
	P          float32    `protobuf:"fixed32,7,opt,name=p,proto3" json:"p,omitempty"`
	PathLength float32    `protobuf:"fixed32,8,opt,name=pathLength,proto3" json:"pathLength,omitempty"`
	Quality    int32      `protobuf:"varint,9,opt,name=quality,proto3" json:"quality,omitempty"`
}

func (m *SimTrackerHit) Reset()                    { *m = SimTrackerHit{} }
func (m *SimTrackerHit) String() string            { return proto.CompactTextString(m) }
func (*SimTrackerHit) ProtoMessage()               {}
func (*SimTrackerHit) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{6} }

func (m *SimTrackerHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *SimTrackerHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *SimTrackerHit) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *SimTrackerHit) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *SimTrackerHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SimTrackerHit) GetMc() *Reference {
	if m != nil {
		return m.Mc
	}
	return nil
}

func (m *SimTrackerHit) GetP() float32 {
	if m != nil {
		return m.P
	}
	return 0
}

func (m *SimTrackerHit) GetPathLength() float32 {
	if m != nil {
		return m.PathLength
	}
	return 0
}

func (m *SimTrackerHit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

type SimTrackerHitCollection struct {
	Flags  int32            `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params          `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Hit    []*SimTrackerHit `protobuf:"bytes,3,rep,name=hit" json:"hit,omitempty"`
}

func (m *SimTrackerHitCollection) Reset()                    { *m = SimTrackerHitCollection{} }
func (m *SimTrackerHitCollection) String() string            { return proto.CompactTextString(m) }
func (*SimTrackerHitCollection) ProtoMessage()               {}
func (*SimTrackerHitCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{7} }

func (m *SimTrackerHitCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *SimTrackerHitCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SimTrackerHitCollection) GetHit() []*SimTrackerHit {
	if m != nil {
		return m.Hit
	}
	return nil
}

type TrackerRawData struct {
	CellID0 int32    `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32    `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    int32    `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
	ADCs    []uint32 `protobuf:"varint,4,rep,packed,name=ADCs" json:"ADCs,omitempty"`
}

func (m *TrackerRawData) Reset()                    { *m = TrackerRawData{} }
func (m *TrackerRawData) String() string            { return proto.CompactTextString(m) }
func (*TrackerRawData) ProtoMessage()               {}
func (*TrackerRawData) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{8} }

func (m *TrackerRawData) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerRawData) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerRawData) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerRawData) GetADCs() []uint32 {
	if m != nil {
		return m.ADCs
	}
	return nil
}

type TrackerRawDataCollection struct {
	Flags  int32             `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params           `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Data   []*TrackerRawData `protobuf:"bytes,3,rep,name=data" json:"data,omitempty"`
}

func (m *TrackerRawDataCollection) Reset()                    { *m = TrackerRawDataCollection{} }
func (m *TrackerRawDataCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerRawDataCollection) ProtoMessage()               {}
func (*TrackerRawDataCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{9} }

func (m *TrackerRawDataCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerRawDataCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerRawDataCollection) GetData() []*TrackerRawData {
	if m != nil {
		return m.Data
	}
	return nil
}

type TrackerData struct {
	CellID0 int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    float32   `protobuf:"fixed32,3,opt,name=time,proto3" json:"time,omitempty"`
	Charges []float32 `protobuf:"fixed32,4,rep,packed,name=charges" json:"charges,omitempty"`
}

func (m *TrackerData) Reset()                    { *m = TrackerData{} }
func (m *TrackerData) String() string            { return proto.CompactTextString(m) }
func (*TrackerData) ProtoMessage()               {}
func (*TrackerData) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{10} }

func (m *TrackerData) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerData) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerData) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerData) GetCharges() []float32 {
	if m != nil {
		return m.Charges
	}
	return nil
}

type TrackerDataCollection struct {
	Flags  int32          `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params        `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Data   []*TrackerData `protobuf:"bytes,3,rep,name=data" json:"data,omitempty"`
}

func (m *TrackerDataCollection) Reset()                    { *m = TrackerDataCollection{} }
func (m *TrackerDataCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerDataCollection) ProtoMessage()               {}
func (*TrackerDataCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{11} }

func (m *TrackerDataCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerDataCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerDataCollection) GetData() []*TrackerData {
	if m != nil {
		return m.Data
	}
	return nil
}

type TrackerHit struct {
	CellID0 int32        `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32        `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32        `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64    `protobuf:"fixed64,4,rep,packed,name=pos" json:"pos,omitempty"`
	Cov     []float64    `protobuf:"fixed64,5,rep,packed,name=cov" json:"cov,omitempty"`
	EDep    float32      `protobuf:"fixed32,6,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32      `protobuf:"fixed32,7,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32      `protobuf:"fixed32,8,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32        `protobuf:"varint,9,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []*Reference `protobuf:"bytes,10,rep,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHit) Reset()                    { *m = TrackerHit{} }
func (m *TrackerHit) String() string            { return proto.CompactTextString(m) }
func (*TrackerHit) ProtoMessage()               {}
func (*TrackerHit) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{12} }

func (m *TrackerHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHit) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHit) GetCov() []float64 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *TrackerHit) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHit) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHit) GetRawHits() []*Reference {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerHitCollection struct {
	Flags  int32         `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params       `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Hit    []*TrackerHit `protobuf:"bytes,3,rep,name=hit" json:"hit,omitempty"`
}

func (m *TrackerHitCollection) Reset()                    { *m = TrackerHitCollection{} }
func (m *TrackerHitCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitCollection) ProtoMessage()               {}
func (*TrackerHitCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{13} }

func (m *TrackerHitCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerHitCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerHitCollection) GetHit() []*TrackerHit {
	if m != nil {
		return m.Hit
	}
	return nil
}

type TrackerPulse struct {
	CellID0 int32      `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32      `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    float32    `protobuf:"fixed32,3,opt,name=time,proto3" json:"time,omitempty"`
	Charge  float32    `protobuf:"fixed32,4,opt,name=charge,proto3" json:"charge,omitempty"`
	Cov     []float32  `protobuf:"fixed32,5,rep,packed,name=cov" json:"cov,omitempty"`
	Quality int32      `protobuf:"varint,6,opt,name=quality,proto3" json:"quality,omitempty"`
	TPC     *Reference `protobuf:"bytes,7,opt,name=TPC" json:"TPC,omitempty"`
}

func (m *TrackerPulse) Reset()                    { *m = TrackerPulse{} }
func (m *TrackerPulse) String() string            { return proto.CompactTextString(m) }
func (*TrackerPulse) ProtoMessage()               {}
func (*TrackerPulse) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{14} }

func (m *TrackerPulse) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerPulse) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerPulse) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerPulse) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *TrackerPulse) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *TrackerPulse) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerPulse) GetTPC() *Reference {
	if m != nil {
		return m.TPC
	}
	return nil
}

type TrackerPulseCollection struct {
	Flags  int32           `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params         `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Pulse  []*TrackerPulse `protobuf:"bytes,3,rep,name=pulse" json:"pulse,omitempty"`
}

func (m *TrackerPulseCollection) Reset()                    { *m = TrackerPulseCollection{} }
func (m *TrackerPulseCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerPulseCollection) ProtoMessage()               {}
func (*TrackerPulseCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{15} }

func (m *TrackerPulseCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerPulseCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerPulseCollection) GetPulse() []*TrackerPulse {
	if m != nil {
		return m.Pulse
	}
	return nil
}

type TrackerHitPlane struct {
	CellID0 int32        `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32        `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32        `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64    `protobuf:"fixed64,4,rep,packed,name=pos" json:"pos,omitempty"`
	U       []float32    `protobuf:"fixed32,5,rep,packed,name=U" json:"U,omitempty"`
	V       []float32    `protobuf:"fixed32,6,rep,packed,name=V" json:"V,omitempty"`
	DU      float32      `protobuf:"fixed32,7,opt,name=dU,proto3" json:"dU,omitempty"`
	DV      float32      `protobuf:"fixed32,8,opt,name=dV,proto3" json:"dV,omitempty"`
	EDep    float32      `protobuf:"fixed32,9,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32      `protobuf:"fixed32,10,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32      `protobuf:"fixed32,11,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32        `protobuf:"varint,12,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []*Reference `protobuf:"bytes,13,rep,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHitPlane) Reset()                    { *m = TrackerHitPlane{} }
func (m *TrackerHitPlane) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitPlane) ProtoMessage()               {}
func (*TrackerHitPlane) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{16} }

func (m *TrackerHitPlane) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHitPlane) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHitPlane) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHitPlane) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHitPlane) GetU() []float32 {
	if m != nil {
		return m.U
	}
	return nil
}

func (m *TrackerHitPlane) GetV() []float32 {
	if m != nil {
		return m.V
	}
	return nil
}

func (m *TrackerHitPlane) GetDU() float32 {
	if m != nil {
		return m.DU
	}
	return 0
}

func (m *TrackerHitPlane) GetDV() float32 {
	if m != nil {
		return m.DV
	}
	return 0
}

func (m *TrackerHitPlane) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHitPlane) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHitPlane) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHitPlane) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHitPlane) GetRawHits() []*Reference {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerHitPlaneCollection struct {
	Flags  int32              `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params            `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Plane  []*TrackerHitPlane `protobuf:"bytes,3,rep,name=plane" json:"plane,omitempty"`
}

func (m *TrackerHitPlaneCollection) Reset()                    { *m = TrackerHitPlaneCollection{} }
func (m *TrackerHitPlaneCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitPlaneCollection) ProtoMessage()               {}
func (*TrackerHitPlaneCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{17} }

func (m *TrackerHitPlaneCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerHitPlaneCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerHitPlaneCollection) GetPlane() []*TrackerHitPlane {
	if m != nil {
		return m.Plane
	}
	return nil
}

type TrackerHitZCylinder struct {
	CellID0 int32        `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32        `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32        `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64    `protobuf:"fixed64,4,rep,packed,name=pos" json:"pos,omitempty"`
	Center  []float32    `protobuf:"fixed32,5,rep,packed,name=center" json:"center,omitempty"`
	DRPhi   float32      `protobuf:"fixed32,6,opt,name=dRPhi,proto3" json:"dRPhi,omitempty"`
	DZ      float32      `protobuf:"fixed32,7,opt,name=dZ,proto3" json:"dZ,omitempty"`
	EDep    float32      `protobuf:"fixed32,8,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32      `protobuf:"fixed32,9,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32      `protobuf:"fixed32,10,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32        `protobuf:"varint,11,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []*Reference `protobuf:"bytes,12,rep,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHitZCylinder) Reset()                    { *m = TrackerHitZCylinder{} }
func (m *TrackerHitZCylinder) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitZCylinder) ProtoMessage()               {}
func (*TrackerHitZCylinder) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{18} }

func (m *TrackerHitZCylinder) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHitZCylinder) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHitZCylinder) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHitZCylinder) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHitZCylinder) GetCenter() []float32 {
	if m != nil {
		return m.Center
	}
	return nil
}

func (m *TrackerHitZCylinder) GetDRPhi() float32 {
	if m != nil {
		return m.DRPhi
	}
	return 0
}

func (m *TrackerHitZCylinder) GetDZ() float32 {
	if m != nil {
		return m.DZ
	}
	return 0
}

func (m *TrackerHitZCylinder) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHitZCylinder) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHitZCylinder) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHitZCylinder) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHitZCylinder) GetRawHits() []*Reference {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerHitZCylinderCollection struct {
	Flags  int32                  `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params                `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Cyl    []*TrackerHitZCylinder `protobuf:"bytes,3,rep,name=cyl" json:"cyl,omitempty"`
}

func (m *TrackerHitZCylinderCollection) Reset()         { *m = TrackerHitZCylinderCollection{} }
func (m *TrackerHitZCylinderCollection) String() string { return proto.CompactTextString(m) }
func (*TrackerHitZCylinderCollection) ProtoMessage()    {}
func (*TrackerHitZCylinderCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorEicio, []int{19}
}

func (m *TrackerHitZCylinderCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerHitZCylinderCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerHitZCylinderCollection) GetCyl() []*TrackerHitZCylinder {
	if m != nil {
		return m.Cyl
	}
	return nil
}

type Track struct {
	Type       int32               `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Chi2       float32             `protobuf:"fixed32,2,opt,name=chi2,proto3" json:"chi2,omitempty"`
	NDF        int32               `protobuf:"varint,3,opt,name=NDF,proto3" json:"NDF,omitempty"`
	DEdx       float32             `protobuf:"fixed32,4,opt,name=dEdx,proto3" json:"dEdx,omitempty"`
	DEdxErr    float32             `protobuf:"fixed32,5,opt,name=dEdxErr,proto3" json:"dEdxErr,omitempty"`
	Radius     float32             `protobuf:"fixed32,6,opt,name=radius,proto3" json:"radius,omitempty"`
	SubDetHits []int32             `protobuf:"varint,7,rep,packed,name=subDetHits" json:"subDetHits,omitempty"`
	States     []*Track_TrackState `protobuf:"bytes,8,rep,name=states" json:"states,omitempty"`
	Hits       []*Reference        `protobuf:"bytes,9,rep,name=hits" json:"hits,omitempty"`
	TrackIDs   []*Reference        `protobuf:"bytes,10,rep,name=trackIDs" json:"trackIDs,omitempty"`
}

func (m *Track) Reset()                    { *m = Track{} }
func (m *Track) String() string            { return proto.CompactTextString(m) }
func (*Track) ProtoMessage()               {}
func (*Track) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{20} }

func (m *Track) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Track) GetChi2() float32 {
	if m != nil {
		return m.Chi2
	}
	return 0
}

func (m *Track) GetNDF() int32 {
	if m != nil {
		return m.NDF
	}
	return 0
}

func (m *Track) GetDEdx() float32 {
	if m != nil {
		return m.DEdx
	}
	return 0
}

func (m *Track) GetDEdxErr() float32 {
	if m != nil {
		return m.DEdxErr
	}
	return 0
}

func (m *Track) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *Track) GetSubDetHits() []int32 {
	if m != nil {
		return m.SubDetHits
	}
	return nil
}

func (m *Track) GetStates() []*Track_TrackState {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *Track) GetHits() []*Reference {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *Track) GetTrackIDs() []*Reference {
	if m != nil {
		return m.TrackIDs
	}
	return nil
}

type Track_TrackState struct {
	Loc   int32     `protobuf:"varint,1,opt,name=loc,proto3" json:"loc,omitempty"`
	D0    float32   `protobuf:"fixed32,2,opt,name=d0,proto3" json:"d0,omitempty"`
	Phi   float32   `protobuf:"fixed32,3,opt,name=phi,proto3" json:"phi,omitempty"`
	Omega float32   `protobuf:"fixed32,4,opt,name=omega,proto3" json:"omega,omitempty"`
	Z0    float32   `protobuf:"fixed32,5,opt,name=z0,proto3" json:"z0,omitempty"`
	TanL  float32   `protobuf:"fixed32,6,opt,name=tanL,proto3" json:"tanL,omitempty"`
	Cov   []float32 `protobuf:"fixed32,7,rep,packed,name=cov" json:"cov,omitempty"`
	Ref   []float32 `protobuf:"fixed32,8,rep,packed,name=ref" json:"ref,omitempty"`
}

func (m *Track_TrackState) Reset()                    { *m = Track_TrackState{} }
func (m *Track_TrackState) String() string            { return proto.CompactTextString(m) }
func (*Track_TrackState) ProtoMessage()               {}
func (*Track_TrackState) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{20, 0} }

func (m *Track_TrackState) GetLoc() int32 {
	if m != nil {
		return m.Loc
	}
	return 0
}

func (m *Track_TrackState) GetD0() float32 {
	if m != nil {
		return m.D0
	}
	return 0
}

func (m *Track_TrackState) GetPhi() float32 {
	if m != nil {
		return m.Phi
	}
	return 0
}

func (m *Track_TrackState) GetOmega() float32 {
	if m != nil {
		return m.Omega
	}
	return 0
}

func (m *Track_TrackState) GetZ0() float32 {
	if m != nil {
		return m.Z0
	}
	return 0
}

func (m *Track_TrackState) GetTanL() float32 {
	if m != nil {
		return m.TanL
	}
	return 0
}

func (m *Track_TrackState) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *Track_TrackState) GetRef() []float32 {
	if m != nil {
		return m.Ref
	}
	return nil
}

type TrackCollection struct {
	Flags  int32    `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params  `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Track  []*Track `protobuf:"bytes,3,rep,name=track" json:"track,omitempty"`
}

func (m *TrackCollection) Reset()                    { *m = TrackCollection{} }
func (m *TrackCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackCollection) ProtoMessage()               {}
func (*TrackCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{21} }

func (m *TrackCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackCollection) GetTrack() []*Track {
	if m != nil {
		return m.Track
	}
	return nil
}

type SimCalorimeterHit struct {
	Params        *Params                      `protobuf:"bytes,1,opt,name=params" json:"params,omitempty"`
	CellID0       int32                        `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1       int32                        `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Energy        float32                      `protobuf:"fixed32,4,opt,name=energy,proto3" json:"energy,omitempty"`
	Pos           []float32                    `protobuf:"fixed32,5,rep,packed,name=pos" json:"pos,omitempty"`
	Contributions []*SimCalorimeterHit_Contrib `protobuf:"bytes,6,rep,name=contributions" json:"contributions,omitempty"`
}

func (m *SimCalorimeterHit) Reset()                    { *m = SimCalorimeterHit{} }
func (m *SimCalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*SimCalorimeterHit) ProtoMessage()               {}
func (*SimCalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{22} }

func (m *SimCalorimeterHit) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SimCalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *SimCalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *SimCalorimeterHit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *SimCalorimeterHit) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *SimCalorimeterHit) GetContributions() []*SimCalorimeterHit_Contrib {
	if m != nil {
		return m.Contributions
	}
	return nil
}

type SimCalorimeterHit_Contrib struct {
	MCParticle int32     `protobuf:"varint,1,opt,name=MCParticle,proto3" json:"MCParticle,omitempty"`
	Energy     float32   `protobuf:"fixed32,2,opt,name=energy,proto3" json:"energy,omitempty"`
	Time       float32   `protobuf:"fixed32,3,opt,name=time,proto3" json:"time,omitempty"`
	PDG        int32     `protobuf:"varint,4,opt,name=PDG,proto3" json:"PDG,omitempty"`
	StepPos    []float32 `protobuf:"fixed32,5,rep,packed,name=stepPos" json:"stepPos,omitempty"`
}

func (m *SimCalorimeterHit_Contrib) Reset()         { *m = SimCalorimeterHit_Contrib{} }
func (m *SimCalorimeterHit_Contrib) String() string { return proto.CompactTextString(m) }
func (*SimCalorimeterHit_Contrib) ProtoMessage()    {}
func (*SimCalorimeterHit_Contrib) Descriptor() ([]byte, []int) {
	return fileDescriptorEicio, []int{22, 0}
}

func (m *SimCalorimeterHit_Contrib) GetMCParticle() int32 {
	if m != nil {
		return m.MCParticle
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetStepPos() []float32 {
	if m != nil {
		return m.StepPos
	}
	return nil
}

type SimCalorimeterHitCollection struct {
	Flags  int32                `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params              `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Hit    []*SimCalorimeterHit `protobuf:"bytes,3,rep,name=hit" json:"hit,omitempty"`
}

func (m *SimCalorimeterHitCollection) Reset()         { *m = SimCalorimeterHitCollection{} }
func (m *SimCalorimeterHitCollection) String() string { return proto.CompactTextString(m) }
func (*SimCalorimeterHitCollection) ProtoMessage()    {}
func (*SimCalorimeterHitCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorEicio, []int{23}
}

func (m *SimCalorimeterHitCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *SimCalorimeterHitCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SimCalorimeterHitCollection) GetHit() []*SimCalorimeterHit {
	if m != nil {
		return m.Hit
	}
	return nil
}

type RawCalorimeterHit struct {
	CellID0   int32 `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1   int32 `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Amplitude int32 `protobuf:"varint,4,opt,name=amplitude,proto3" json:"amplitude,omitempty"`
	TimeStamp int32 `protobuf:"varint,5,opt,name=timeStamp,proto3" json:"timeStamp,omitempty"`
}

func (m *RawCalorimeterHit) Reset()                    { *m = RawCalorimeterHit{} }
func (m *RawCalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*RawCalorimeterHit) ProtoMessage()               {}
func (*RawCalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{24} }

func (m *RawCalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *RawCalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *RawCalorimeterHit) GetAmplitude() int32 {
	if m != nil {
		return m.Amplitude
	}
	return 0
}

func (m *RawCalorimeterHit) GetTimeStamp() int32 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

type RawCalorimeterHitCollection struct {
	Flags  int32                `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params              `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Hit    []*RawCalorimeterHit `protobuf:"bytes,3,rep,name=hit" json:"hit,omitempty"`
}

func (m *RawCalorimeterHitCollection) Reset()         { *m = RawCalorimeterHitCollection{} }
func (m *RawCalorimeterHitCollection) String() string { return proto.CompactTextString(m) }
func (*RawCalorimeterHitCollection) ProtoMessage()    {}
func (*RawCalorimeterHitCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorEicio, []int{25}
}

func (m *RawCalorimeterHitCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RawCalorimeterHitCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *RawCalorimeterHitCollection) GetHit() []*RawCalorimeterHit {
	if m != nil {
		return m.Hit
	}
	return nil
}

type CalorimeterHit struct {
	CellID0   int32      `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1   int32      `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Energy    float32    `protobuf:"fixed32,3,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyErr float32    `protobuf:"fixed32,4,opt,name=energyErr,proto3" json:"energyErr,omitempty"`
	Time      float32    `protobuf:"fixed32,5,opt,name=time,proto3" json:"time,omitempty"`
	Pos       []float32  `protobuf:"fixed32,6,rep,packed,name=pos" json:"pos,omitempty"`
	Type      int32      `protobuf:"varint,7,opt,name=type,proto3" json:"type,omitempty"`
	Raw       *Reference `protobuf:"bytes,8,opt,name=raw" json:"raw,omitempty"`
}

func (m *CalorimeterHit) Reset()                    { *m = CalorimeterHit{} }
func (m *CalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*CalorimeterHit) ProtoMessage()               {}
func (*CalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{26} }

func (m *CalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *CalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *CalorimeterHit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *CalorimeterHit) GetEnergyErr() float32 {
	if m != nil {
		return m.EnergyErr
	}
	return 0
}

func (m *CalorimeterHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *CalorimeterHit) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *CalorimeterHit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CalorimeterHit) GetRaw() *Reference {
	if m != nil {
		return m.Raw
	}
	return nil
}

type CalorimeterHitCollection struct {
	Flags  int32             `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params           `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Hit    []*CalorimeterHit `protobuf:"bytes,3,rep,name=hit" json:"hit,omitempty"`
}

func (m *CalorimeterHitCollection) Reset()                    { *m = CalorimeterHitCollection{} }
func (m *CalorimeterHitCollection) String() string            { return proto.CompactTextString(m) }
func (*CalorimeterHitCollection) ProtoMessage()               {}
func (*CalorimeterHitCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{27} }

func (m *CalorimeterHitCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *CalorimeterHitCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *CalorimeterHitCollection) GetHit() []*CalorimeterHit {
	if m != nil {
		return m.Hit
	}
	return nil
}

type Cluster struct {
	Type       int32         `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Energy     float32       `protobuf:"fixed32,2,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyErr  float32       `protobuf:"fixed32,3,opt,name=energyErr,proto3" json:"energyErr,omitempty"`
	Pos        []float32     `protobuf:"fixed32,4,rep,packed,name=pos" json:"pos,omitempty"`
	PosErr     []float32     `protobuf:"fixed32,5,rep,packed,name=posErr" json:"posErr,omitempty"`
	Theta      float32       `protobuf:"fixed32,6,opt,name=theta,proto3" json:"theta,omitempty"`
	Phi        float32       `protobuf:"fixed32,7,opt,name=phi,proto3" json:"phi,omitempty"`
	DirErr     []float32     `protobuf:"fixed32,8,rep,packed,name=dirErr" json:"dirErr,omitempty"`
	Shape      []float32     `protobuf:"fixed32,9,rep,packed,name=shape" json:"shape,omitempty"`
	PIDs       []*ParticleID `protobuf:"bytes,10,rep,name=PIDs" json:"PIDs,omitempty"`
	Hits       []*Reference  `protobuf:"bytes,11,rep,name=hits" json:"hits,omitempty"`
	Weights    []float32     `protobuf:"fixed32,12,rep,packed,name=weights" json:"weights,omitempty"`
	SubDetEnes []float32     `protobuf:"fixed32,13,rep,packed,name=subDetEnes" json:"subDetEnes,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{28} }

func (m *Cluster) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Cluster) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *Cluster) GetEnergyErr() float32 {
	if m != nil {
		return m.EnergyErr
	}
	return 0
}

func (m *Cluster) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Cluster) GetPosErr() []float32 {
	if m != nil {
		return m.PosErr
	}
	return nil
}

func (m *Cluster) GetTheta() float32 {
	if m != nil {
		return m.Theta
	}
	return 0
}

func (m *Cluster) GetPhi() float32 {
	if m != nil {
		return m.Phi
	}
	return 0
}

func (m *Cluster) GetDirErr() []float32 {
	if m != nil {
		return m.DirErr
	}
	return nil
}

func (m *Cluster) GetShape() []float32 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *Cluster) GetPIDs() []*ParticleID {
	if m != nil {
		return m.PIDs
	}
	return nil
}

func (m *Cluster) GetHits() []*Reference {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *Cluster) GetWeights() []float32 {
	if m != nil {
		return m.Weights
	}
	return nil
}

func (m *Cluster) GetSubDetEnes() []float32 {
	if m != nil {
		return m.SubDetEnes
	}
	return nil
}

type ClusterCollection struct {
	Flags   int32      `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params    `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Cluster []*Cluster `protobuf:"bytes,3,rep,name=cluster" json:"cluster,omitempty"`
}

func (m *ClusterCollection) Reset()                    { *m = ClusterCollection{} }
func (m *ClusterCollection) String() string            { return proto.CompactTextString(m) }
func (*ClusterCollection) ProtoMessage()               {}
func (*ClusterCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{29} }

func (m *ClusterCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ClusterCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *ClusterCollection) GetCluster() []*Cluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

type RecParticle struct {
	Type          int32         `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	P             []float32     `protobuf:"fixed32,2,rep,packed,name=p" json:"p,omitempty"`
	Energy        float32       `protobuf:"fixed32,3,opt,name=energy,proto3" json:"energy,omitempty"`
	Cov           []float32     `protobuf:"fixed32,4,rep,packed,name=cov" json:"cov,omitempty"`
	Mass          float32       `protobuf:"fixed32,5,opt,name=mass,proto3" json:"mass,omitempty"`
	Charge        float32       `protobuf:"fixed32,6,opt,name=charge,proto3" json:"charge,omitempty"`
	Ref           []float32     `protobuf:"fixed32,7,rep,packed,name=ref" json:"ref,omitempty"`
	PIDs          []*ParticleID `protobuf:"bytes,8,rep,name=PIDs" json:"PIDs,omitempty"`
	PIDUsed       int32         `protobuf:"varint,9,opt,name=PIDUsed,proto3" json:"PIDUsed,omitempty"`
	GoodnessOfPID float32       `protobuf:"fixed32,10,opt,name=goodnessOfPID,proto3" json:"goodnessOfPID,omitempty"`
	Recs          []*Reference  `protobuf:"bytes,11,rep,name=recs" json:"recs,omitempty"`
	Tracks        []*Reference  `protobuf:"bytes,12,rep,name=tracks" json:"tracks,omitempty"`
	Clusters      []*Reference  `protobuf:"bytes,13,rep,name=clusters" json:"clusters,omitempty"`
	StartVtx      *Reference    `protobuf:"bytes,14,opt,name=startVtx" json:"startVtx,omitempty"`
}

func (m *RecParticle) Reset()                    { *m = RecParticle{} }
func (m *RecParticle) String() string            { return proto.CompactTextString(m) }
func (*RecParticle) ProtoMessage()               {}
func (*RecParticle) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{30} }

func (m *RecParticle) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RecParticle) GetP() []float32 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *RecParticle) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *RecParticle) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *RecParticle) GetMass() float32 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *RecParticle) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *RecParticle) GetRef() []float32 {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *RecParticle) GetPIDs() []*ParticleID {
	if m != nil {
		return m.PIDs
	}
	return nil
}

func (m *RecParticle) GetPIDUsed() int32 {
	if m != nil {
		return m.PIDUsed
	}
	return 0
}

func (m *RecParticle) GetGoodnessOfPID() float32 {
	if m != nil {
		return m.GoodnessOfPID
	}
	return 0
}

func (m *RecParticle) GetRecs() []*Reference {
	if m != nil {
		return m.Recs
	}
	return nil
}

func (m *RecParticle) GetTracks() []*Reference {
	if m != nil {
		return m.Tracks
	}
	return nil
}

func (m *RecParticle) GetClusters() []*Reference {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *RecParticle) GetStartVtx() *Reference {
	if m != nil {
		return m.StartVtx
	}
	return nil
}

type RecParticleCollection struct {
	Flags    int32          `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params   *Params        `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Particle []*RecParticle `protobuf:"bytes,3,rep,name=particle" json:"particle,omitempty"`
}

func (m *RecParticleCollection) Reset()                    { *m = RecParticleCollection{} }
func (m *RecParticleCollection) String() string            { return proto.CompactTextString(m) }
func (*RecParticleCollection) ProtoMessage()               {}
func (*RecParticleCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{31} }

func (m *RecParticleCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RecParticleCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *RecParticleCollection) GetParticle() []*RecParticle {
	if m != nil {
		return m.Particle
	}
	return nil
}

type Vertex struct {
	Primary int32      `protobuf:"varint,1,opt,name=primary,proto3" json:"primary,omitempty"`
	AlgType int32      `protobuf:"varint,2,opt,name=algType,proto3" json:"algType,omitempty"`
	Chi2    float32    `protobuf:"fixed32,3,opt,name=chi2,proto3" json:"chi2,omitempty"`
	Prob    float32    `protobuf:"fixed32,4,opt,name=prob,proto3" json:"prob,omitempty"`
	Pos     []float32  `protobuf:"fixed32,5,rep,packed,name=pos" json:"pos,omitempty"`
	Cov     []float32  `protobuf:"fixed32,6,rep,packed,name=cov" json:"cov,omitempty"`
	Params  []float32  `protobuf:"fixed32,7,rep,packed,name=params" json:"params,omitempty"`
	RecPart *Reference `protobuf:"bytes,8,opt,name=recPart" json:"recPart,omitempty"`
}

func (m *Vertex) Reset()                    { *m = Vertex{} }
func (m *Vertex) String() string            { return proto.CompactTextString(m) }
func (*Vertex) ProtoMessage()               {}
func (*Vertex) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{32} }

func (m *Vertex) GetPrimary() int32 {
	if m != nil {
		return m.Primary
	}
	return 0
}

func (m *Vertex) GetAlgType() int32 {
	if m != nil {
		return m.AlgType
	}
	return 0
}

func (m *Vertex) GetChi2() float32 {
	if m != nil {
		return m.Chi2
	}
	return 0
}

func (m *Vertex) GetProb() float32 {
	if m != nil {
		return m.Prob
	}
	return 0
}

func (m *Vertex) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Vertex) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *Vertex) GetParams() []float32 {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Vertex) GetRecPart() *Reference {
	if m != nil {
		return m.RecPart
	}
	return nil
}

type VertexCollection struct {
	Flags  int32     `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params *Params   `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Vertex []*Vertex `protobuf:"bytes,3,rep,name=vertex" json:"vertex,omitempty"`
}

func (m *VertexCollection) Reset()                    { *m = VertexCollection{} }
func (m *VertexCollection) String() string            { return proto.CompactTextString(m) }
func (*VertexCollection) ProtoMessage()               {}
func (*VertexCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{33} }

func (m *VertexCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *VertexCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *VertexCollection) GetVertex() []*Vertex {
	if m != nil {
		return m.Vertex
	}
	return nil
}

type Relation struct {
	From   *Reference `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	To     *Reference `protobuf:"bytes,2,opt,name=to" json:"to,omitempty"`
	Weight float32    `protobuf:"fixed32,3,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *Relation) Reset()                    { *m = Relation{} }
func (m *Relation) String() string            { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()               {}
func (*Relation) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{34} }

func (m *Relation) GetFrom() *Reference {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Relation) GetTo() *Reference {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *Relation) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

type RelationCollection struct {
	Flags    int32       `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Params   *Params     `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	Relation []*Relation `protobuf:"bytes,3,rep,name=relation" json:"relation,omitempty"`
}

func (m *RelationCollection) Reset()                    { *m = RelationCollection{} }
func (m *RelationCollection) String() string            { return proto.CompactTextString(m) }
func (*RelationCollection) ProtoMessage()               {}
func (*RelationCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{35} }

func (m *RelationCollection) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RelationCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *RelationCollection) GetRelation() []*Relation {
	if m != nil {
		return m.Relation
	}
	return nil
}

func init() {
	proto.RegisterType((*EventHeader)(nil), "eicio.EventHeader")
	proto.RegisterType((*EventHeader_CollectionHeader)(nil), "eicio.EventHeader.CollectionHeader")
	proto.RegisterType((*Params)(nil), "eicio.Params")
	proto.RegisterType((*Reference)(nil), "eicio.Reference")
	proto.RegisterType((*ParticleID)(nil), "eicio.ParticleID")
	proto.RegisterType((*MCParticle)(nil), "eicio.MCParticle")
	proto.RegisterType((*MCParticleCollection)(nil), "eicio.MCParticleCollection")
	proto.RegisterType((*SimTrackerHit)(nil), "eicio.SimTrackerHit")
	proto.RegisterType((*SimTrackerHitCollection)(nil), "eicio.SimTrackerHitCollection")
	proto.RegisterType((*TrackerRawData)(nil), "eicio.TrackerRawData")
	proto.RegisterType((*TrackerRawDataCollection)(nil), "eicio.TrackerRawDataCollection")
	proto.RegisterType((*TrackerData)(nil), "eicio.TrackerData")
	proto.RegisterType((*TrackerDataCollection)(nil), "eicio.TrackerDataCollection")
	proto.RegisterType((*TrackerHit)(nil), "eicio.TrackerHit")
	proto.RegisterType((*TrackerHitCollection)(nil), "eicio.TrackerHitCollection")
	proto.RegisterType((*TrackerPulse)(nil), "eicio.TrackerPulse")
	proto.RegisterType((*TrackerPulseCollection)(nil), "eicio.TrackerPulseCollection")
	proto.RegisterType((*TrackerHitPlane)(nil), "eicio.TrackerHitPlane")
	proto.RegisterType((*TrackerHitPlaneCollection)(nil), "eicio.TrackerHitPlaneCollection")
	proto.RegisterType((*TrackerHitZCylinder)(nil), "eicio.TrackerHitZCylinder")
	proto.RegisterType((*TrackerHitZCylinderCollection)(nil), "eicio.TrackerHitZCylinderCollection")
	proto.RegisterType((*Track)(nil), "eicio.Track")
	proto.RegisterType((*Track_TrackState)(nil), "eicio.Track.TrackState")
	proto.RegisterType((*TrackCollection)(nil), "eicio.TrackCollection")
	proto.RegisterType((*SimCalorimeterHit)(nil), "eicio.SimCalorimeterHit")
	proto.RegisterType((*SimCalorimeterHit_Contrib)(nil), "eicio.SimCalorimeterHit.Contrib")
	proto.RegisterType((*SimCalorimeterHitCollection)(nil), "eicio.SimCalorimeterHitCollection")
	proto.RegisterType((*RawCalorimeterHit)(nil), "eicio.RawCalorimeterHit")
	proto.RegisterType((*RawCalorimeterHitCollection)(nil), "eicio.RawCalorimeterHitCollection")
	proto.RegisterType((*CalorimeterHit)(nil), "eicio.CalorimeterHit")
	proto.RegisterType((*CalorimeterHitCollection)(nil), "eicio.CalorimeterHitCollection")
	proto.RegisterType((*Cluster)(nil), "eicio.Cluster")
	proto.RegisterType((*ClusterCollection)(nil), "eicio.ClusterCollection")
	proto.RegisterType((*RecParticle)(nil), "eicio.RecParticle")
	proto.RegisterType((*RecParticleCollection)(nil), "eicio.RecParticleCollection")
	proto.RegisterType((*Vertex)(nil), "eicio.Vertex")
	proto.RegisterType((*VertexCollection)(nil), "eicio.VertexCollection")
	proto.RegisterType((*Relation)(nil), "eicio.Relation")
	proto.RegisterType((*RelationCollection)(nil), "eicio.RelationCollection")
	proto.RegisterEnum("eicio.EventHeader_CollectionHeader_Type", EventHeader_CollectionHeader_Type_name, EventHeader_CollectionHeader_Type_value)
}
func (m *EventHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Version))
	}
	if m.RunNumber != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.RunNumber))
	}
	if m.EventNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.EventNumber))
	}
	if m.TimeStamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.TimeStamp))
	}
	if len(m.Detector) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Detector)))
		i += copy(dAtA[i:], m.Detector)
	}
	if m.Params != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n1, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Collection) > 0 {
		for _, msg := range m.Collection {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	return i, nil
}

func (m *EventHeader_CollectionHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventHeader_CollectionHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.PayloadSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.PayloadSize))
	}
	return i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ints) > 0 {
		for k, _ := range m.Ints {
			dAtA[i] = 0xa
			i++
			v := m.Ints[k]
			mapSize := 1 + len(k) + sovEicio(uint64(len(k))) + 1 + sovEicio(uint64(v))
			i = encodeVarintEicio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintEicio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintEicio(dAtA, i, uint64(v))
		}
	}
	if len(m.Floats) > 0 {
		for k, _ := range m.Floats {
			dAtA[i] = 0x12
			i++
			v := m.Floats[k]
			mapSize := 1 + len(k) + sovEicio(uint64(len(k))) + 1 + 4
			i = encodeVarintEicio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintEicio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(v))))
		}
	}
	if len(m.Strings) > 0 {
		for k, _ := range m.Strings {
			dAtA[i] = 0x1a
			i++
			v := m.Strings[k]
			mapSize := 1 + len(k) + sovEicio(uint64(len(k))) + 1 + len(v) + sovEicio(uint64(len(v)))
			i = encodeVarintEicio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintEicio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintEicio(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *Reference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CollID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CollID))
	}
	if m.EntryID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.EntryID))
	}
	return i, nil
}

func (m *ParticleID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParticleID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Likelihood != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Likelihood))))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if m.PDG != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.PDG))
	}
	if m.AlgType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.AlgType))
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Params)*4))
		for _, num := range m.Params {
			f2 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f2)
			i++
			dAtA[i] = uint8(f2 >> 8)
			i++
			dAtA[i] = uint8(f2 >> 16)
			i++
			dAtA[i] = uint8(f2 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *MCParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MCParticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Parents) > 0 {
		dAtA4 := make([]byte, len(m.Parents)*10)
		var j3 int
		for _, num1 := range m.Parents {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintEicio(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.Children) > 0 {
		dAtA6 := make([]byte, len(m.Children)*10)
		var j5 int
		for _, num1 := range m.Children {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if m.PDG != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.PDG))
	}
	if len(m.Vertex) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Vertex)*8))
		for _, num := range m.Vertex {
			f7 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f7)
			i++
			dAtA[i] = uint8(f7 >> 8)
			i++
			dAtA[i] = uint8(f7 >> 16)
			i++
			dAtA[i] = uint8(f7 >> 24)
			i++
			dAtA[i] = uint8(f7 >> 32)
			i++
			dAtA[i] = uint8(f7 >> 40)
			i++
			dAtA[i] = uint8(f7 >> 48)
			i++
			dAtA[i] = uint8(f7 >> 56)
			i++
		}
	}
	if m.Time != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.P)*8))
		for _, num := range m.P {
			f8 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f8)
			i++
			dAtA[i] = uint8(f8 >> 8)
			i++
			dAtA[i] = uint8(f8 >> 16)
			i++
			dAtA[i] = uint8(f8 >> 24)
			i++
			dAtA[i] = uint8(f8 >> 32)
			i++
			dAtA[i] = uint8(f8 >> 40)
			i++
			dAtA[i] = uint8(f8 >> 48)
			i++
			dAtA[i] = uint8(f8 >> 56)
			i++
		}
	}
	if m.Mass != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Eicio(dAtA, i, uint64(math.Float64bits(float64(m.Mass))))
	}
	if m.Charge != 0 {
		dAtA[i] = 0x45
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Charge))))
	}
	if len(m.PEndPoint) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.PEndPoint)*8))
		for _, num := range m.PEndPoint {
			f9 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f9)
			i++
			dAtA[i] = uint8(f9 >> 8)
			i++
			dAtA[i] = uint8(f9 >> 16)
			i++
			dAtA[i] = uint8(f9 >> 24)
			i++
			dAtA[i] = uint8(f9 >> 32)
			i++
			dAtA[i] = uint8(f9 >> 40)
			i++
			dAtA[i] = uint8(f9 >> 48)
			i++
			dAtA[i] = uint8(f9 >> 56)
			i++
		}
	}
	if len(m.Spin) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Spin)*4))
		for _, num := range m.Spin {
			f10 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f10)
			i++
			dAtA[i] = uint8(f10 >> 8)
			i++
			dAtA[i] = uint8(f10 >> 16)
			i++
			dAtA[i] = uint8(f10 >> 24)
			i++
		}
	}
	if len(m.ColorFlow) > 0 {
		dAtA12 := make([]byte, len(m.ColorFlow)*10)
		var j11 int
		for _, num1 := range m.ColorFlow {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if m.GenStatus != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.GenStatus))
	}
	if m.SimStatus != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.SimStatus))
	}
	return i, nil
}

func (m *MCParticleCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MCParticleCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n13, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Particle) > 0 {
		for _, msg := range m.Particle {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SimTrackerHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimTrackerHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f14 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f14)
			i++
			dAtA[i] = uint8(f14 >> 8)
			i++
			dAtA[i] = uint8(f14 >> 16)
			i++
			dAtA[i] = uint8(f14 >> 24)
			i++
			dAtA[i] = uint8(f14 >> 32)
			i++
			dAtA[i] = uint8(f14 >> 40)
			i++
			dAtA[i] = uint8(f14 >> 48)
			i++
			dAtA[i] = uint8(f14 >> 56)
			i++
		}
	}
	if m.EDep != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDep))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.Mc != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Mc.Size()))
		n15, err := m.Mc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.P != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.P))))
	}
	if m.PathLength != 0 {
		dAtA[i] = 0x45
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.PathLength))))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Quality))
	}
	return i, nil
}

func (m *SimTrackerHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimTrackerHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n16, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.Hit) > 0 {
		for _, msg := range m.Hit {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerRawData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerRawData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Time))
	}
	if len(m.ADCs) > 0 {
		dAtA18 := make([]byte, len(m.ADCs)*10)
		var j17 int
		for _, num := range m.ADCs {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintEicio(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	return i, nil
}

func (m *TrackerRawDataCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerRawDataCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n19, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if len(m.Charges) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Charges)*4))
		for _, num := range m.Charges {
			f20 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f20)
			i++
			dAtA[i] = uint8(f20 >> 8)
			i++
			dAtA[i] = uint8(f20 >> 16)
			i++
			dAtA[i] = uint8(f20 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *TrackerDataCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerDataCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n21, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f22 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f22)
			i++
			dAtA[i] = uint8(f22 >> 8)
			i++
			dAtA[i] = uint8(f22 >> 16)
			i++
			dAtA[i] = uint8(f22 >> 24)
			i++
			dAtA[i] = uint8(f22 >> 32)
			i++
			dAtA[i] = uint8(f22 >> 40)
			i++
			dAtA[i] = uint8(f22 >> 48)
			i++
			dAtA[i] = uint8(f22 >> 56)
			i++
		}
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Cov)*8))
		for _, num := range m.Cov {
			f23 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f23)
			i++
			dAtA[i] = uint8(f23 >> 8)
			i++
			dAtA[i] = uint8(f23 >> 16)
			i++
			dAtA[i] = uint8(f23 >> 24)
			i++
			dAtA[i] = uint8(f23 >> 32)
			i++
			dAtA[i] = uint8(f23 >> 40)
			i++
			dAtA[i] = uint8(f23 >> 48)
			i++
			dAtA[i] = uint8(f23 >> 56)
			i++
		}
	}
	if m.EDep != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDep))))
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDepErr))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x45
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, msg := range m.RawHits {
			dAtA[i] = 0x52
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n24, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.Hit) > 0 {
		for _, msg := range m.Hit {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerPulse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerPulse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.Charge != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Charge))))
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f25 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f25)
			i++
			dAtA[i] = uint8(f25 >> 8)
			i++
			dAtA[i] = uint8(f25 >> 16)
			i++
			dAtA[i] = uint8(f25 >> 24)
			i++
		}
	}
	if m.Quality != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Quality))
	}
	if m.TPC != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.TPC.Size()))
		n26, err := m.TPC.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *TrackerPulseCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerPulseCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n27, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Pulse) > 0 {
		for _, msg := range m.Pulse {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitPlane) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitPlane) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f28 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f28)
			i++
			dAtA[i] = uint8(f28 >> 8)
			i++
			dAtA[i] = uint8(f28 >> 16)
			i++
			dAtA[i] = uint8(f28 >> 24)
			i++
			dAtA[i] = uint8(f28 >> 32)
			i++
			dAtA[i] = uint8(f28 >> 40)
			i++
			dAtA[i] = uint8(f28 >> 48)
			i++
			dAtA[i] = uint8(f28 >> 56)
			i++
		}
	}
	if len(m.U) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.U)*4))
		for _, num := range m.U {
			f29 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f29)
			i++
			dAtA[i] = uint8(f29 >> 8)
			i++
			dAtA[i] = uint8(f29 >> 16)
			i++
			dAtA[i] = uint8(f29 >> 24)
			i++
		}
	}
	if len(m.V) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.V)*4))
		for _, num := range m.V {
			f30 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f30)
			i++
			dAtA[i] = uint8(f30 >> 8)
			i++
			dAtA[i] = uint8(f30 >> 16)
			i++
			dAtA[i] = uint8(f30 >> 24)
			i++
		}
	}
	if m.DU != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DU))))
	}
	if m.DV != 0 {
		dAtA[i] = 0x45
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DV))))
	}
	if m.EDep != 0 {
		dAtA[i] = 0x4d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDep))))
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x55
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDepErr))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x5d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, msg := range m.RawHits {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitPlaneCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitPlaneCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n31, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Plane) > 0 {
		for _, msg := range m.Plane {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitZCylinder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitZCylinder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f32 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f32)
			i++
			dAtA[i] = uint8(f32 >> 8)
			i++
			dAtA[i] = uint8(f32 >> 16)
			i++
			dAtA[i] = uint8(f32 >> 24)
			i++
			dAtA[i] = uint8(f32 >> 32)
			i++
			dAtA[i] = uint8(f32 >> 40)
			i++
			dAtA[i] = uint8(f32 >> 48)
			i++
			dAtA[i] = uint8(f32 >> 56)
			i++
		}
	}
	if len(m.Center) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Center)*4))
		for _, num := range m.Center {
			f33 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f33)
			i++
			dAtA[i] = uint8(f33 >> 8)
			i++
			dAtA[i] = uint8(f33 >> 16)
			i++
			dAtA[i] = uint8(f33 >> 24)
			i++
		}
	}
	if m.DRPhi != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DRPhi))))
	}
	if m.DZ != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DZ))))
	}
	if m.EDep != 0 {
		dAtA[i] = 0x45
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDep))))
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x4d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDepErr))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x55
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, msg := range m.RawHits {
			dAtA[i] = 0x62
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitZCylinderCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitZCylinderCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n34, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.Cyl) > 0 {
		for _, msg := range m.Cyl {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Track) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Track) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if m.Chi2 != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Chi2))))
	}
	if m.NDF != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.NDF))
	}
	if m.DEdx != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DEdx))))
	}
	if m.DEdxErr != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DEdxErr))))
	}
	if m.Radius != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Radius))))
	}
	if len(m.SubDetHits) > 0 {
		dAtA36 := make([]byte, len(m.SubDetHits)*10)
		var j35 int
		for _, num1 := range m.SubDetHits {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(j35))
		i += copy(dAtA[i:], dAtA36[:j35])
	}
	if len(m.States) > 0 {
		for _, msg := range m.States {
			dAtA[i] = 0x42
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hits) > 0 {
		for _, msg := range m.Hits {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TrackIDs) > 0 {
		for _, msg := range m.TrackIDs {
			dAtA[i] = 0x52
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Track_TrackState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Track_TrackState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Loc != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Loc))
	}
	if m.D0 != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.D0))))
	}
	if m.Phi != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Phi))))
	}
	if m.Omega != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Omega))))
	}
	if m.Z0 != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Z0))))
	}
	if m.TanL != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.TanL))))
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f37 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f37)
			i++
			dAtA[i] = uint8(f37 >> 8)
			i++
			dAtA[i] = uint8(f37 >> 16)
			i++
			dAtA[i] = uint8(f37 >> 24)
			i++
		}
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Ref)*4))
		for _, num := range m.Ref {
			f38 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f38)
			i++
			dAtA[i] = uint8(f38 >> 8)
			i++
			dAtA[i] = uint8(f38 >> 16)
			i++
			dAtA[i] = uint8(f38 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *TrackCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n39, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.Track) > 0 {
		for _, msg := range m.Track {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SimCalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Params != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n40, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Energy))))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f41 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f41)
			i++
			dAtA[i] = uint8(f41 >> 8)
			i++
			dAtA[i] = uint8(f41 >> 16)
			i++
			dAtA[i] = uint8(f41 >> 24)
			i++
		}
	}
	if len(m.Contributions) > 0 {
		for _, msg := range m.Contributions {
			dAtA[i] = 0x32
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SimCalorimeterHit_Contrib) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHit_Contrib) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MCParticle != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.MCParticle))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Energy))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.PDG != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.PDG))
	}
	if len(m.StepPos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.StepPos)*4))
		for _, num := range m.StepPos {
			f42 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f42)
			i++
			dAtA[i] = uint8(f42 >> 8)
			i++
			dAtA[i] = uint8(f42 >> 16)
			i++
			dAtA[i] = uint8(f42 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *SimCalorimeterHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n43, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if len(m.Hit) > 0 {
		for _, msg := range m.Hit {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawCalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Amplitude != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Amplitude))
	}
	if m.TimeStamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.TimeStamp))
	}
	return i, nil
}

func (m *RawCalorimeterHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCalorimeterHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n44, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if len(m.Hit) > 0 {
		for _, msg := range m.Hit {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Energy))))
	}
	if m.EnergyErr != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EnergyErr))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f45 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f45)
			i++
			dAtA[i] = uint8(f45 >> 8)
			i++
			dAtA[i] = uint8(f45 >> 16)
			i++
			dAtA[i] = uint8(f45 >> 24)
			i++
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if m.Raw != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Raw.Size()))
		n46, err := m.Raw.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}

func (m *CalorimeterHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalorimeterHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n47, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if len(m.Hit) > 0 {
		for _, msg := range m.Hit {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Energy))))
	}
	if m.EnergyErr != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EnergyErr))))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f48 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f48)
			i++
			dAtA[i] = uint8(f48 >> 8)
			i++
			dAtA[i] = uint8(f48 >> 16)
			i++
			dAtA[i] = uint8(f48 >> 24)
			i++
		}
	}
	if len(m.PosErr) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.PosErr)*4))
		for _, num := range m.PosErr {
			f49 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f49)
			i++
			dAtA[i] = uint8(f49 >> 8)
			i++
			dAtA[i] = uint8(f49 >> 16)
			i++
			dAtA[i] = uint8(f49 >> 24)
			i++
		}
	}
	if m.Theta != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Theta))))
	}
	if m.Phi != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Phi))))
	}
	if len(m.DirErr) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.DirErr)*4))
		for _, num := range m.DirErr {
			f50 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f50)
			i++
			dAtA[i] = uint8(f50 >> 8)
			i++
			dAtA[i] = uint8(f50 >> 16)
			i++
			dAtA[i] = uint8(f50 >> 24)
			i++
		}
	}
	if len(m.Shape) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Shape)*4))
		for _, num := range m.Shape {
			f51 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f51)
			i++
			dAtA[i] = uint8(f51 >> 8)
			i++
			dAtA[i] = uint8(f51 >> 16)
			i++
			dAtA[i] = uint8(f51 >> 24)
			i++
		}
	}
	if len(m.PIDs) > 0 {
		for _, msg := range m.PIDs {
			dAtA[i] = 0x52
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hits) > 0 {
		for _, msg := range m.Hits {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Weights) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Weights)*4))
		for _, num := range m.Weights {
			f52 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f52)
			i++
			dAtA[i] = uint8(f52 >> 8)
			i++
			dAtA[i] = uint8(f52 >> 16)
			i++
			dAtA[i] = uint8(f52 >> 24)
			i++
		}
	}
	if len(m.SubDetEnes) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.SubDetEnes)*4))
		for _, num := range m.SubDetEnes {
			f53 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f53)
			i++
			dAtA[i] = uint8(f53 >> 8)
			i++
			dAtA[i] = uint8(f53 >> 16)
			i++
			dAtA[i] = uint8(f53 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *ClusterCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n54, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if len(m.Cluster) > 0 {
		for _, msg := range m.Cluster {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RecParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecParticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.P)*4))
		for _, num := range m.P {
			f55 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f55)
			i++
			dAtA[i] = uint8(f55 >> 8)
			i++
			dAtA[i] = uint8(f55 >> 16)
			i++
			dAtA[i] = uint8(f55 >> 24)
			i++
		}
	}
	if m.Energy != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Energy))))
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f56 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f56)
			i++
			dAtA[i] = uint8(f56 >> 8)
			i++
			dAtA[i] = uint8(f56 >> 16)
			i++
			dAtA[i] = uint8(f56 >> 24)
			i++
		}
	}
	if m.Mass != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Mass))))
	}
	if m.Charge != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Charge))))
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Ref)*4))
		for _, num := range m.Ref {
			f57 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f57)
			i++
			dAtA[i] = uint8(f57 >> 8)
			i++
			dAtA[i] = uint8(f57 >> 16)
			i++
			dAtA[i] = uint8(f57 >> 24)
			i++
		}
	}
	if len(m.PIDs) > 0 {
		for _, msg := range m.PIDs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PIDUsed != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.PIDUsed))
	}
	if m.GoodnessOfPID != 0 {
		dAtA[i] = 0x55
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.GoodnessOfPID))))
	}
	if len(m.Recs) > 0 {
		for _, msg := range m.Recs {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tracks) > 0 {
		for _, msg := range m.Tracks {
			dAtA[i] = 0x62
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Clusters) > 0 {
		for _, msg := range m.Clusters {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.StartVtx != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.StartVtx.Size()))
		n58, err := m.StartVtx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}

func (m *RecParticleCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecParticleCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n59, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if len(m.Particle) > 0 {
		for _, msg := range m.Particle {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Vertex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vertex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Primary != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Primary))
	}
	if m.AlgType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.AlgType))
	}
	if m.Chi2 != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Chi2))))
	}
	if m.Prob != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Prob))))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f60 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f60)
			i++
			dAtA[i] = uint8(f60 >> 8)
			i++
			dAtA[i] = uint8(f60 >> 16)
			i++
			dAtA[i] = uint8(f60 >> 24)
			i++
		}
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f61 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f61)
			i++
			dAtA[i] = uint8(f61 >> 8)
			i++
			dAtA[i] = uint8(f61 >> 16)
			i++
			dAtA[i] = uint8(f61 >> 24)
			i++
		}
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Params)*4))
		for _, num := range m.Params {
			f62 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f62)
			i++
			dAtA[i] = uint8(f62 >> 8)
			i++
			dAtA[i] = uint8(f62 >> 16)
			i++
			dAtA[i] = uint8(f62 >> 24)
			i++
		}
	}
	if m.RecPart != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.RecPart.Size()))
		n63, err := m.RecPart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	return i, nil
}

func (m *VertexCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VertexCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n64, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if len(m.Vertex) > 0 {
		for _, msg := range m.Vertex {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Relation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.From.Size()))
		n65, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.To != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.To.Size()))
		n66, err := m.To.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.Weight != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Weight))))
	}
	return i, nil
}

func (m *RelationCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n67, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if len(m.Relation) > 0 {
		for _, msg := range m.Relation {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Eicio(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Eicio(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintEicio(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EventHeader) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovEicio(uint64(m.Version))
	}
	if m.RunNumber != 0 {
		n += 1 + sovEicio(uint64(m.RunNumber))
	}
	if m.EventNumber != 0 {
		n += 1 + sovEicio(uint64(m.EventNumber))
	}
	if m.TimeStamp != 0 {
		n += 1 + sovEicio(uint64(m.TimeStamp))
	}
	l = len(m.Detector)
	if l > 0 {
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Collection) > 0 {
		for _, e := range m.Collection {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 2 + l + sovEicio(uint64(l))
	}
	return n
}

func (m *EventHeader_CollectionHeader) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.PayloadSize != 0 {
		n += 1 + sovEicio(uint64(m.PayloadSize))
	}
	return n
}

func (m *Params) Size() (n int) {
	var l int
	_ = l
	if len(m.Ints) > 0 {
		for k, v := range m.Ints {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEicio(uint64(len(k))) + 1 + sovEicio(uint64(v))
			n += mapEntrySize + 1 + sovEicio(uint64(mapEntrySize))
		}
	}
	if len(m.Floats) > 0 {
		for k, v := range m.Floats {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEicio(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 1 + sovEicio(uint64(mapEntrySize))
		}
	}
	if len(m.Strings) > 0 {
		for k, v := range m.Strings {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEicio(uint64(len(k))) + 1 + len(v) + sovEicio(uint64(len(v)))
			n += mapEntrySize + 1 + sovEicio(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Reference) Size() (n int) {
	var l int
	_ = l
	if m.CollID != 0 {
		n += 1 + sovEicio(uint64(m.CollID))
	}
	if m.EntryID != 0 {
		n += 1 + sovEicio(uint64(m.EntryID))
	}
	return n
}

func (m *ParticleID) Size() (n int) {
	var l int
	_ = l
	if m.Likelihood != 0 {
		n += 5
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if m.PDG != 0 {
		n += 1 + sovEicio(uint64(m.PDG))
	}
	if m.AlgType != 0 {
		n += 1 + sovEicio(uint64(m.AlgType))
	}
	if len(m.Params) > 0 {
		n += 1 + sovEicio(uint64(len(m.Params)*4)) + len(m.Params)*4
	}
	return n
}

func (m *MCParticle) Size() (n int) {
	var l int
	_ = l
	if len(m.Parents) > 0 {
		l = 0
		for _, e := range m.Parents {
			l += sovEicio(uint64(e))
		}
		n += 1 + sovEicio(uint64(l)) + l
	}
	if len(m.Children) > 0 {
		l = 0
		for _, e := range m.Children {
			l += sovEicio(uint64(e))
		}
		n += 1 + sovEicio(uint64(l)) + l
	}
	if m.PDG != 0 {
		n += 1 + sovEicio(uint64(m.PDG))
	}
	if len(m.Vertex) > 0 {
		n += 1 + sovEicio(uint64(len(m.Vertex)*8)) + len(m.Vertex)*8
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.P) > 0 {
		n += 1 + sovEicio(uint64(len(m.P)*8)) + len(m.P)*8
	}
	if m.Mass != 0 {
		n += 9
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.PEndPoint) > 0 {
		n += 1 + sovEicio(uint64(len(m.PEndPoint)*8)) + len(m.PEndPoint)*8
	}
	if len(m.Spin) > 0 {
		n += 1 + sovEicio(uint64(len(m.Spin)*4)) + len(m.Spin)*4
	}
	if len(m.ColorFlow) > 0 {
		l = 0
		for _, e := range m.ColorFlow {
			l += sovEicio(uint64(e))
		}
		n += 1 + sovEicio(uint64(l)) + l
	}
	if m.GenStatus != 0 {
		n += 1 + sovEicio(uint64(m.GenStatus))
	}
	if m.SimStatus != 0 {
		n += 1 + sovEicio(uint64(m.SimStatus))
	}
	return n
}

func (m *MCParticleCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Particle) > 0 {
		for _, e := range m.Particle {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *SimTrackerHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Mc != nil {
		l = m.Mc.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.P != 0 {
		n += 5
	}
	if m.PathLength != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovEicio(uint64(m.Quality))
	}
	return n
}

func (m *SimTrackerHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Hit) > 0 {
		for _, e := range m.Hit {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerRawData) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 1 + sovEicio(uint64(m.Time))
	}
	if len(m.ADCs) > 0 {
		l = 0
		for _, e := range m.ADCs {
			l += sovEicio(uint64(e))
		}
		n += 1 + sovEicio(uint64(l)) + l
	}
	return n
}

func (m *TrackerRawDataCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerData) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.Charges) > 0 {
		n += 1 + sovEicio(uint64(len(m.Charges)*4)) + len(m.Charges)*4
	}
	return n
}

func (m *TrackerDataCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.Cov) > 0 {
		n += 1 + sovEicio(uint64(len(m.Cov)*8)) + len(m.Cov)*8
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovEicio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, e := range m.RawHits {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Hit) > 0 {
		for _, e := range m.Hit {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerPulse) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovEicio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if m.Quality != 0 {
		n += 1 + sovEicio(uint64(m.Quality))
	}
	if m.TPC != nil {
		l = m.TPC.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	return n
}

func (m *TrackerPulseCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Pulse) > 0 {
		for _, e := range m.Pulse {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitPlane) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.U) > 0 {
		n += 1 + sovEicio(uint64(len(m.U)*4)) + len(m.U)*4
	}
	if len(m.V) > 0 {
		n += 1 + sovEicio(uint64(len(m.V)*4)) + len(m.V)*4
	}
	if m.DU != 0 {
		n += 5
	}
	if m.DV != 0 {
		n += 5
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovEicio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, e := range m.RawHits {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitPlaneCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Plane) > 0 {
		for _, e := range m.Plane {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitZCylinder) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.Center) > 0 {
		n += 1 + sovEicio(uint64(len(m.Center)*4)) + len(m.Center)*4
	}
	if m.DRPhi != 0 {
		n += 5
	}
	if m.DZ != 0 {
		n += 5
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovEicio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, e := range m.RawHits {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitZCylinderCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Cyl) > 0 {
		for _, e := range m.Cyl {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *Track) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if m.Chi2 != 0 {
		n += 5
	}
	if m.NDF != 0 {
		n += 1 + sovEicio(uint64(m.NDF))
	}
	if m.DEdx != 0 {
		n += 5
	}
	if m.DEdxErr != 0 {
		n += 5
	}
	if m.Radius != 0 {
		n += 5
	}
	if len(m.SubDetHits) > 0 {
		l = 0
		for _, e := range m.SubDetHits {
			l += sovEicio(uint64(e))
		}
		n += 1 + sovEicio(uint64(l)) + l
	}
	if len(m.States) > 0 {
		for _, e := range m.States {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Hits) > 0 {
		for _, e := range m.Hits {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.TrackIDs) > 0 {
		for _, e := range m.TrackIDs {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *Track_TrackState) Size() (n int) {
	var l int
	_ = l
	if m.Loc != 0 {
		n += 1 + sovEicio(uint64(m.Loc))
	}
	if m.D0 != 0 {
		n += 5
	}
	if m.Phi != 0 {
		n += 5
	}
	if m.Omega != 0 {
		n += 5
	}
	if m.Z0 != 0 {
		n += 5
	}
	if m.TanL != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovEicio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if len(m.Ref) > 0 {
		n += 1 + sovEicio(uint64(len(m.Ref)*4)) + len(m.Ref)*4
	}
	return n
}

func (m *TrackCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Track) > 0 {
		for _, e := range m.Track {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *SimCalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Energy != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.Contributions) > 0 {
		for _, e := range m.Contributions {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *SimCalorimeterHit_Contrib) Size() (n int) {
	var l int
	_ = l
	if m.MCParticle != 0 {
		n += 1 + sovEicio(uint64(m.MCParticle))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.PDG != 0 {
		n += 1 + sovEicio(uint64(m.PDG))
	}
	if len(m.StepPos) > 0 {
		n += 1 + sovEicio(uint64(len(m.StepPos)*4)) + len(m.StepPos)*4
	}
	return n
}

func (m *SimCalorimeterHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Hit) > 0 {
		for _, e := range m.Hit {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *RawCalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Amplitude != 0 {
		n += 1 + sovEicio(uint64(m.Amplitude))
	}
	if m.TimeStamp != 0 {
		n += 1 + sovEicio(uint64(m.TimeStamp))
	}
	return n
}

func (m *RawCalorimeterHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Hit) > 0 {
		for _, e := range m.Hit {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *CalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.EnergyErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if m.Raw != nil {
		l = m.Raw.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	return n
}

func (m *CalorimeterHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Hit) > 0 {
		for _, e := range m.Hit {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.EnergyErr != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.PosErr) > 0 {
		n += 1 + sovEicio(uint64(len(m.PosErr)*4)) + len(m.PosErr)*4
	}
	if m.Theta != 0 {
		n += 5
	}
	if m.Phi != 0 {
		n += 5
	}
	if len(m.DirErr) > 0 {
		n += 1 + sovEicio(uint64(len(m.DirErr)*4)) + len(m.DirErr)*4
	}
	if len(m.Shape) > 0 {
		n += 1 + sovEicio(uint64(len(m.Shape)*4)) + len(m.Shape)*4
	}
	if len(m.PIDs) > 0 {
		for _, e := range m.PIDs {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Hits) > 0 {
		for _, e := range m.Hits {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Weights) > 0 {
		n += 1 + sovEicio(uint64(len(m.Weights)*4)) + len(m.Weights)*4
	}
	if len(m.SubDetEnes) > 0 {
		n += 1 + sovEicio(uint64(len(m.SubDetEnes)*4)) + len(m.SubDetEnes)*4
	}
	return n
}

func (m *ClusterCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Cluster) > 0 {
		for _, e := range m.Cluster {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *RecParticle) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if len(m.P) > 0 {
		n += 1 + sovEicio(uint64(len(m.P)*4)) + len(m.P)*4
	}
	if m.Energy != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovEicio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if m.Mass != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.Ref) > 0 {
		n += 1 + sovEicio(uint64(len(m.Ref)*4)) + len(m.Ref)*4
	}
	if len(m.PIDs) > 0 {
		for _, e := range m.PIDs {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if m.PIDUsed != 0 {
		n += 1 + sovEicio(uint64(m.PIDUsed))
	}
	if m.GoodnessOfPID != 0 {
		n += 5
	}
	if len(m.Recs) > 0 {
		for _, e := range m.Recs {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Tracks) > 0 {
		for _, e := range m.Tracks {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if m.StartVtx != nil {
		l = m.StartVtx.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	return n
}

func (m *RecParticleCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Particle) > 0 {
		for _, e := range m.Particle {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *Vertex) Size() (n int) {
	var l int
	_ = l
	if m.Primary != 0 {
		n += 1 + sovEicio(uint64(m.Primary))
	}
	if m.AlgType != 0 {
		n += 1 + sovEicio(uint64(m.AlgType))
	}
	if m.Chi2 != 0 {
		n += 5
	}
	if m.Prob != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.Cov) > 0 {
		n += 1 + sovEicio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if len(m.Params) > 0 {
		n += 1 + sovEicio(uint64(len(m.Params)*4)) + len(m.Params)*4
	}
	if m.RecPart != nil {
		l = m.RecPart.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	return n
}

func (m *VertexCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Vertex) > 0 {
		for _, e := range m.Vertex {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *Relation) Size() (n int) {
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.Weight != 0 {
		n += 5
	}
	return n
}

func (m *RelationCollection) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Relation) > 0 {
		for _, e := range m.Relation {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func sovEicio(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEicio(x uint64) (n int) {
	return sovEicio(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunNumber", wireType)
			}
			m.RunNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunNumber |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNumber", wireType)
			}
			m.EventNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNumber |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = append(m.Collection, &EventHeader_CollectionHeader{})
			if err := m.Collection[len(m.Collection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventHeader_CollectionHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (EventHeader_CollectionHeader_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ints == nil {
				m.Ints = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEicio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEicio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthEicio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ints[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Floats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Floats == nil {
				m.Floats = make(map[string]float32)
			}
			var mapkey string
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEicio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvaluetemp = uint32(dAtA[iNdEx-4])
					mapvaluetemp |= uint32(dAtA[iNdEx-3]) << 8
					mapvaluetemp |= uint32(dAtA[iNdEx-2]) << 16
					mapvaluetemp |= uint32(dAtA[iNdEx-1]) << 24
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEicio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthEicio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Floats[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strings == nil {
				m.Strings = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEicio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEicio
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEicio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthEicio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Strings[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollID", wireType)
			}
			m.CollID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryID", wireType)
			}
			m.EntryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParticleID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParticleID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParticleID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Likelihood", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Likelihood = float32(math.Float32frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgType", wireType)
			}
			m.AlgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Params = append(m.Params, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Params = append(m.Params, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MCParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MCParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MCParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parents = append(m.Parents, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parents = append(m.Parents, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Children = append(m.Children, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Children = append(m.Children, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Vertex = append(m.Vertex, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Vertex = append(m.Vertex, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vertex", wireType)
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Mass = float64(math.Float64frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Charge = float32(math.Float32frombits(v))
		case 9:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.PEndPoint = append(m.PEndPoint, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.PEndPoint = append(m.PEndPoint, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PEndPoint", wireType)
			}
		case 10:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Spin = append(m.Spin, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Spin = append(m.Spin, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Spin", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColorFlow = append(m.ColorFlow, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColorFlow = append(m.ColorFlow, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorFlow", wireType)
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenStatus", wireType)
			}
			m.GenStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimStatus", wireType)
			}
			m.SimStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SimStatus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MCParticleCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MCParticleCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MCParticleCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Particle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Particle = append(m.Particle, &MCParticle{})
			if err := m.Particle[len(m.Particle)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimTrackerHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimTrackerHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimTrackerHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDep = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mc == nil {
				m.Mc = &Reference{}
			}
			if err := m.Mc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.P = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathLength", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.PathLength = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimTrackerHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimTrackerHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimTrackerHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hit = append(m.Hit, &SimTrackerHit{})
			if err := m.Hit[len(m.Hit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerRawData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerRawData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerRawData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ADCs = append(m.ADCs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ADCs = append(m.ADCs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ADCs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerRawDataCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerRawDataCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerRawDataCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &TrackerRawData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Charges = append(m.Charges, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Charges = append(m.Charges, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Charges", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerDataCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerDataCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerDataCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &TrackerData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDep = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDepErr = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawHits = append(m.RawHits, &Reference{})
			if err := m.RawHits[len(m.RawHits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hit = append(m.Hit, &TrackerHit{})
			if err := m.Hit[len(m.Hit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerPulse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerPulse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerPulse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Charge = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TPC == nil {
				m.TPC = &Reference{}
			}
			if err := m.TPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerPulseCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerPulseCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerPulseCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pulse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pulse = append(m.Pulse, &TrackerPulse{})
			if err := m.Pulse[len(m.Pulse)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitPlane) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitPlane: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitPlane: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.U = append(m.U, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.U = append(m.U, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field U", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.V = append(m.V, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.V = append(m.V, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DU = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DV", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DV = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDep = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDepErr = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawHits = append(m.RawHits, &Reference{})
			if err := m.RawHits[len(m.RawHits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitPlaneCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitPlaneCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitPlaneCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plane", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plane = append(m.Plane, &TrackerHitPlane{})
			if err := m.Plane[len(m.Plane)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitZCylinder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitZCylinder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitZCylinder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Center = append(m.Center, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Center = append(m.Center, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Center", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DRPhi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DRPhi = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DZ = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDep = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDepErr = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawHits = append(m.RawHits, &Reference{})
			if err := m.RawHits[len(m.RawHits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitZCylinderCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitZCylinderCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitZCylinderCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cyl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cyl = append(m.Cyl, &TrackerHitZCylinder{})
			if err := m.Cyl[len(m.Cyl)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Track) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Track: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Track: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chi2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Chi2 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NDF", wireType)
			}
			m.NDF = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NDF |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEdx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DEdx = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEdxErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DEdxErr = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Radius = float32(math.Float32frombits(v))
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SubDetHits = append(m.SubDetHits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SubDetHits = append(m.SubDetHits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDetHits", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = append(m.States, &Track_TrackState{})
			if err := m.States[len(m.States)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hits = append(m.Hits, &Reference{})
			if err := m.Hits[len(m.Hits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackIDs = append(m.TrackIDs, &Reference{})
			if err := m.TrackIDs[len(m.TrackIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Track_TrackState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loc", wireType)
			}
			m.Loc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field D0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.D0 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Phi = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Omega", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Omega = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Z0 = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TanL", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.TanL = float32(math.Float32frombits(v))
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Ref = append(m.Ref, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Ref = append(m.Ref, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Track", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Track = append(m.Track, &Track{})
			if err := m.Track[len(m.Track)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimCalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimCalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Energy = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contributions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contributions = append(m.Contributions, &SimCalorimeterHit_Contrib{})
			if err := m.Contributions[len(m.Contributions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHit_Contrib) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contrib: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contrib: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MCParticle", wireType)
			}
			m.MCParticle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MCParticle |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Energy = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.StepPos = append(m.StepPos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.StepPos = append(m.StepPos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StepPos", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimCalorimeterHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimCalorimeterHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hit = append(m.Hit, &SimCalorimeterHit{})
			if err := m.Hit[len(m.Hit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amplitude", wireType)
			}
			m.Amplitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amplitude |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCalorimeterHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCalorimeterHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCalorimeterHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hit = append(m.Hit, &RawCalorimeterHit{})
			if err := m.Hit[len(m.Hit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Energy = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EnergyErr = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Raw == nil {
				m.Raw = &Reference{}
			}
			if err := m.Raw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalorimeterHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalorimeterHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalorimeterHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hit = append(m.Hit, &CalorimeterHit{})
			if err := m.Hit[len(m.Hit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Energy = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EnergyErr = float32(math.Float32frombits(v))
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.PosErr = append(m.PosErr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.PosErr = append(m.PosErr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PosErr", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Theta", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Theta = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Phi = float32(math.Float32frombits(v))
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.DirErr = append(m.DirErr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.DirErr = append(m.DirErr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DirErr", wireType)
			}
		case 9:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Shape = append(m.Shape, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Shape = append(m.Shape, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIDs = append(m.PIDs, &ParticleID{})
			if err := m.PIDs[len(m.PIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hits = append(m.Hits, &Reference{})
			if err := m.Hits[len(m.Hits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Weights = append(m.Weights, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Weights = append(m.Weights, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
		case 13:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.SubDetEnes = append(m.SubDetEnes, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.SubDetEnes = append(m.SubDetEnes, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDetEnes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = append(m.Cluster, &Cluster{})
			if err := m.Cluster[len(m.Cluster)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Energy = float32(math.Float32frombits(v))
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Mass = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Charge = float32(math.Float32frombits(v))
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Ref = append(m.Ref, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Ref = append(m.Ref, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIDs = append(m.PIDs, &ParticleID{})
			if err := m.PIDs[len(m.PIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDUsed", wireType)
			}
			m.PIDUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PIDUsed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodnessOfPID", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.GoodnessOfPID = float32(math.Float32frombits(v))
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recs = append(m.Recs, &Reference{})
			if err := m.Recs[len(m.Recs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tracks = append(m.Tracks, &Reference{})
			if err := m.Tracks[len(m.Tracks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &Reference{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartVtx == nil {
				m.StartVtx = &Reference{}
			}
			if err := m.StartVtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecParticleCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecParticleCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecParticleCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Particle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Particle = append(m.Particle, &RecParticle{})
			if err := m.Particle[len(m.Particle)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vertex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vertex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vertex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			m.Primary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Primary |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgType", wireType)
			}
			m.AlgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chi2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Chi2 = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prob", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Prob = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Params = append(m.Params, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Params = append(m.Params, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecPart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecPart == nil {
				m.RecPart = &Reference{}
			}
			if err := m.RecPart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VertexCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VertexCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VertexCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vertex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vertex = append(m.Vertex, &Vertex{})
			if err := m.Vertex[len(m.Vertex)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Reference{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &Reference{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Weight = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relation = append(m.Relation, &Relation{})
			if err := m.Relation[len(m.Relation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEicio(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEicio
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEicio(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEicio = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEicio   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("eicio.proto", fileDescriptorEicio) }

var fileDescriptorEicio = []byte{
	// 2250 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xcd, 0x8f, 0xdc, 0x48,
	0x15, 0x5f, 0xdb, 0xfd, 0xf9, 0x7a, 0x7a, 0xe2, 0xa9, 0x4d, 0x26, 0xde, 0x21, 0x44, 0x2d, 0xef,
	0x06, 0x9a, 0xdd, 0x65, 0xc8, 0x06, 0x24, 0x60, 0x05, 0x07, 0x98, 0x9e, 0x90, 0x91, 0x96, 0x6c,
	0xab, 0x26, 0x99, 0x43, 0x6e, 0x8e, 0x5d, 0x33, 0x6d, 0xe2, 0xb6, 0x8d, 0x5d, 0x3d, 0x93, 0x8e,
	0xd0, 0x6a, 0x81, 0x15, 0x07, 0xfe, 0x02, 0x4e, 0xfc, 0x01, 0x48, 0x88, 0x13, 0x1c, 0x39, 0x22,
	0x0e, 0x80, 0x38, 0x22, 0x4e, 0x28, 0x20, 0xc1, 0x9f, 0x81, 0x5e, 0x7d, 0xf8, 0xa3, 0xc7, 0x9d,
	0xa0, 0xd0, 0xb9, 0xcc, 0xd4, 0x7b, 0xf5, 0xea, 0xe3, 0xfd, 0xde, 0xa7, 0xab, 0x61, 0xc0, 0x42,
	0x3f, 0x4c, 0xf6, 0xd3, 0x2c, 0xe1, 0x09, 0x69, 0x0b, 0xc2, 0xfd, 0x4f, 0x1b, 0x06, 0x87, 0xe7,
	0x2c, 0xe6, 0xf7, 0x98, 0x17, 0xb0, 0x8c, 0x38, 0xd0, 0x3d, 0x67, 0x59, 0x1e, 0x26, 0xb1, 0x63,
	0x8c, 0x8c, 0xf1, 0x90, 0x6a, 0x92, 0xdc, 0x80, 0x7e, 0xb6, 0x88, 0xef, 0x2f, 0xe6, 0x8f, 0x59,
	0xe6, 0x98, 0x23, 0x63, 0xdc, 0xa2, 0x25, 0x83, 0x8c, 0x60, 0xc0, 0x70, 0x1b, 0x35, 0x6f, 0x89,
	0xf9, 0x2a, 0x0b, 0xd7, 0xf3, 0x70, 0xce, 0x8e, 0xb9, 0x37, 0x4f, 0x9d, 0x96, 0x5c, 0x5f, 0x30,
	0xc8, 0x1e, 0xf4, 0x02, 0xc6, 0x99, 0xcf, 0x93, 0xcc, 0x69, 0x8f, 0x8c, 0x71, 0x9f, 0x16, 0x34,
	0xb9, 0x05, 0x9d, 0xd4, 0xcb, 0xbc, 0x79, 0xee, 0x74, 0x46, 0xc6, 0x78, 0x70, 0x67, 0xb8, 0x2f,
	0x15, 0x99, 0x0a, 0x26, 0x55, 0x93, 0xe4, 0x00, 0xc0, 0x4f, 0xa2, 0x88, 0xf9, 0x1c, 0x6f, 0xdf,
	0x1d, 0x59, 0xe3, 0xc1, 0x9d, 0xb7, 0x95, 0x68, 0x45, 0xc5, 0xfd, 0x83, 0x42, 0x48, 0x32, 0x68,
	0x65, 0x19, 0xea, 0x11, 0xb0, 0xdc, 0xcf, 0xc2, 0x54, 0xec, 0x62, 0x8b, 0xab, 0x54, 0x59, 0x7b,
	0xbf, 0xb3, 0xc0, 0x5e, 0xdd, 0x82, 0x7c, 0x0b, 0x5a, 0x7c, 0x99, 0x32, 0x81, 0xd9, 0xf6, 0x9d,
	0xf1, 0xff, 0x70, 0xea, 0xfe, 0x83, 0x65, 0xca, 0xa8, 0x58, 0x45, 0x08, 0xb4, 0x62, 0x6f, 0xce,
	0x04, 0xaa, 0x7d, 0x2a, 0xc6, 0x78, 0x91, 0xd4, 0x5b, 0x46, 0x89, 0x17, 0x1c, 0x87, 0xcf, 0x98,
	0x00, 0x74, 0x48, 0xab, 0x2c, 0xf7, 0xd7, 0x26, 0xb4, 0x70, 0x13, 0xd2, 0x83, 0xd6, 0xfd, 0x8f,
	0xef, 0x1f, 0xda, 0x6f, 0x90, 0x6d, 0x80, 0xef, 0x1f, 0x4c, 0xbd, 0x8c, 0x87, 0x7e, 0xc4, 0x6c,
	0x83, 0xec, 0xc0, 0xf0, 0x38, 0x9c, 0x3f, 0xc8, 0x3c, 0xff, 0x09, 0xcb, 0xee, 0x85, 0xdc, 0x36,
	0xc9, 0x15, 0x18, 0x28, 0x7a, 0xe2, 0x71, 0xcf, 0xb6, 0x08, 0x81, 0x6d, 0xc5, 0xa0, 0xde, 0x85,
	0xe0, 0xb5, 0x70, 0x9f, 0xca, 0xa2, 0x36, 0xb1, 0x61, 0x4b, 0xd1, 0xd3, 0x45, 0x94, 0x33, 0xbb,
	0x43, 0xde, 0x84, 0x2b, 0xa5, 0xc4, 0x34, 0xf2, 0x62, 0x66, 0x77, 0xc9, 0x75, 0x78, 0xb3, 0x64,
	0x3e, 0x3a, 0x58, 0x46, 0x61, 0x1c, 0xb0, 0xcc, 0xee, 0x91, 0x3e, 0xb4, 0xc5, 0x84, 0xdd, 0x27,
	0xd7, 0x60, 0xe7, 0x38, 0x9c, 0x1f, 0x78, 0x51, 0x92, 0x85, 0x73, 0xc6, 0xe5, 0x09, 0x80, 0x6c,
	0xea, 0x5d, 0xac, 0xb0, 0x07, 0x78, 0xb9, 0x15, 0xde, 0x16, 0x19, 0x40, 0xf7, 0x20, 0x5a, 0xe4,
	0x9c, 0x65, 0xf6, 0x10, 0xd5, 0xa1, 0xcc, 0x2f, 0x54, 0xde, 0x26, 0x00, 0x9d, 0x13, 0x96, 0x71,
	0xf6, 0xd4, 0xbe, 0x42, 0xb6, 0xa0, 0x47, 0x59, 0xe4, 0x21, 0xe8, 0xb6, 0xed, 0xfe, 0xc5, 0x84,
	0x8e, 0x74, 0x19, 0xf2, 0x1e, 0xb4, 0xc2, 0x98, 0xe7, 0x8e, 0x21, 0x9c, 0xe4, 0x7a, 0xcd, 0x9f,
	0xf6, 0x8f, 0x62, 0x9e, 0x1f, 0xc6, 0x3c, 0x5b, 0x52, 0x21, 0x44, 0x3e, 0x80, 0xce, 0x69, 0x94,
	0x78, 0x3c, 0x77, 0x4c, 0x21, 0xfe, 0x56, 0x5d, 0xfc, 0xae, 0x98, 0x93, 0x0b, 0x94, 0x20, 0xf9,
	0x1a, 0x74, 0x73, 0x9e, 0x85, 0xf1, 0x59, 0xee, 0x58, 0x62, 0xcd, 0x5e, 0x7d, 0xcd, 0xb1, 0x9c,
	0x94, 0x8b, 0xb4, 0xe8, 0xde, 0xd7, 0xa1, 0x5f, 0x9c, 0x4d, 0x6c, 0xb0, 0x9e, 0xb0, 0xa5, 0x70,
	0xa8, 0x3e, 0xc5, 0x21, 0xb9, 0x0a, 0xed, 0x73, 0x2f, 0x5a, 0x48, 0x37, 0x69, 0x53, 0x49, 0x7c,
	0x68, 0x7e, 0xc3, 0xd8, 0xfb, 0x26, 0x0c, 0x2a, 0xb7, 0x78, 0xd9, 0x52, 0xb3, 0xba, 0xf4, 0x43,
	0xd8, 0xaa, 0x5e, 0xe6, 0x65, 0x6b, 0xfb, 0x95, 0xb5, 0xee, 0xb7, 0xa1, 0x4f, 0xd9, 0x29, 0xcb,
	0x58, 0xec, 0x33, 0xb2, 0x0b, 0x1d, 0x0c, 0xa3, 0xa3, 0x89, 0xca, 0x1b, 0x8a, 0xc2, 0x84, 0xc2,
	0x70, 0xe7, 0xa3, 0x89, 0xd8, 0x60, 0x48, 0x35, 0xe9, 0x7e, 0x66, 0x00, 0x68, 0xc3, 0x1d, 0x4d,
	0xc8, 0x4d, 0x80, 0x28, 0x7c, 0xc2, 0xa2, 0x70, 0x96, 0x24, 0x81, 0xd8, 0xc4, 0xa4, 0x15, 0x0e,
	0x06, 0x89, 0x08, 0x31, 0xa9, 0xbd, 0x0c, 0x1c, 0x1b, 0xac, 0xe9, 0xe4, 0x7b, 0x22, 0x38, 0xda,
	0x14, 0x87, 0x78, 0x9c, 0x17, 0x9d, 0x61, 0x58, 0x88, 0x1c, 0xd3, 0xa6, 0x9a, 0xc4, 0x0b, 0xaa,
	0x2c, 0xd2, 0x1e, 0x59, 0x63, 0x53, 0xa7, 0x0d, 0xf7, 0x0f, 0x66, 0x35, 0x68, 0x70, 0x83, 0xd4,
	0xcb, 0x98, 0xf6, 0x8e, 0x36, 0xd5, 0x24, 0xa6, 0x28, 0x7f, 0x16, 0x46, 0x41, 0xc6, 0x62, 0xe1,
	0x09, 0x6d, 0x5a, 0xd0, 0x0d, 0x17, 0xd9, 0x85, 0xce, 0xb9, 0xf0, 0x43, 0xa7, 0x35, 0xb2, 0xc6,
	0x06, 0x55, 0x94, 0x50, 0x23, 0x9c, 0x33, 0x91, 0xe4, 0x4c, 0x2a, 0xc6, 0x64, 0x0b, 0x8c, 0xd4,
	0xe9, 0x08, 0x31, 0x23, 0x45, 0x89, 0xb9, 0x97, 0xe7, 0x4e, 0x77, 0x64, 0x8c, 0x0d, 0x2a, 0xc6,
	0x02, 0xdd, 0x99, 0x97, 0x9d, 0x31, 0xa7, 0x27, 0xd6, 0x29, 0x0a, 0x93, 0xea, 0xf4, 0x30, 0x0e,
	0xa6, 0x49, 0x18, 0x73, 0xa7, 0x2f, 0x76, 0x28, 0x19, 0xb8, 0x53, 0x9e, 0x86, 0xb1, 0x03, 0x42,
	0x61, 0x31, 0xc6, 0x15, 0x7e, 0x12, 0x25, 0xd9, 0xdd, 0x28, 0xb9, 0x70, 0x06, 0x42, 0x8d, 0x92,
	0x81, 0xb3, 0x67, 0x2c, 0x3e, 0xe6, 0x1e, 0x5f, 0xe4, 0xce, 0x96, 0xd0, 0xa6, 0x64, 0xe0, 0x6c,
	0x1e, 0xce, 0xd5, 0xec, 0x50, 0x58, 0xb3, 0x64, 0xb8, 0x3f, 0x31, 0xe0, 0x6a, 0x09, 0x64, 0x99,
	0xef, 0xd0, 0x83, 0x4e, 0x23, 0xef, 0x2c, 0x17, 0x46, 0x6d, 0x53, 0x49, 0x54, 0xb2, 0xba, 0xf9,
	0xa2, 0xac, 0xfe, 0x65, 0xe8, 0xa5, 0x6a, 0x4b, 0x15, 0x4b, 0x3b, 0x4a, 0xb0, 0x3c, 0x8b, 0x16,
	0x22, 0xee, 0xbf, 0x8d, 0x95, 0x94, 0x87, 0x06, 0xf5, 0x19, 0xba, 0xe2, 0x6d, 0x75, 0xbe, 0x26,
	0xcb, 0x99, 0x0f, 0x94, 0x53, 0x69, 0x12, 0xcd, 0x99, 0x26, 0x32, 0x76, 0x0d, 0x8a, 0x43, 0x84,
	0xf2, 0x70, 0xc2, 0x64, 0xe1, 0x32, 0xa9, 0x18, 0x37, 0x9a, 0x72, 0x04, 0xe6, 0xdc, 0x57, 0x75,
	0xca, 0x56, 0x17, 0x2d, 0x82, 0x84, 0x9a, 0x73, 0x5f, 0x1a, 0xbb, 0x2b, 0x96, 0x18, 0x29, 0x7a,
	0x7d, 0xea, 0xf1, 0xd9, 0x47, 0x2c, 0x3e, 0xe3, 0x33, 0x65, 0xdc, 0x0a, 0x07, 0xef, 0xf8, 0xc3,
	0x85, 0x17, 0x85, 0x7c, 0xe9, 0xf4, 0xe5, 0x1d, 0x15, 0xe9, 0x7e, 0x02, 0xd7, 0x6b, 0x8a, 0x6e,
	0x0a, 0xf0, 0x2f, 0x80, 0x35, 0x0b, 0xb9, 0xc2, 0xfa, 0xaa, 0x92, 0xa9, 0x9d, 0x44, 0x51, 0xc0,
	0x8d, 0x56, 0xeb, 0xc6, 0x2b, 0x21, 0xad, 0x31, 0xb4, 0x54, 0x54, 0x23, 0x86, 0x04, 0x5a, 0xdf,
	0x99, 0x1c, 0xe4, 0x22, 0x70, 0x86, 0x54, 0x8c, 0xd1, 0xb9, 0x9c, 0xfa, 0x71, 0x9b, 0xd2, 0xf7,
	0x4b, 0xd0, 0x0a, 0x3c, 0xee, 0x29, 0x85, 0xaf, 0x29, 0xa1, 0xfa, 0x59, 0x54, 0x88, 0xb8, 0x49,
	0xad, 0x76, 0xfe, 0xdf, 0xfa, 0x6a, 0x9f, 0x41, 0x69, 0x11, 0xce, 0x52, 0x65, 0x93, 0x6a, 0xd2,
	0xfd, 0x11, 0x5c, 0xab, 0x1c, 0xb8, 0x39, 0x0b, 0x57, 0x35, 0x26, 0x75, 0x8d, 0x2b, 0xea, 0x7e,
	0x6a, 0x56, 0xdb, 0x80, 0x57, 0x56, 0x17, 0x73, 0xb1, 0x55, 0x4f, 0xda, 0x18, 0x5c, 0xad, 0x32,
	0xb8, 0x6c, 0xb0, 0xfc, 0xe4, 0x5c, 0xe4, 0x65, 0x83, 0xe2, 0xb0, 0x08, 0xb7, 0x4e, 0x25, 0xdc,
	0x1c, 0xe8, 0xe2, 0xff, 0xc3, 0x2c, 0x53, 0xe1, 0xa3, 0xc9, 0x02, 0xd4, 0x5e, 0x1d, 0xd4, 0xe6,
	0xc0, 0x21, 0xef, 0x42, 0x37, 0xf3, 0x2e, 0xee, 0x85, 0x3c, 0x17, 0x89, 0xb1, 0x29, 0x4e, 0xb5,
	0x80, 0xfb, 0x14, 0xae, 0x6e, 0x3e, 0xc2, 0xde, 0xae, 0x46, 0xd8, 0x4e, 0x1d, 0xfe, 0x22, 0xbc,
	0x7e, 0x6f, 0xd4, 0x7b, 0xae, 0x8d, 0x79, 0x5b, 0x59, 0x4a, 0x5a, 0xb5, 0x52, 0x52, 0x31, 0x82,
	0x29, 0x8d, 0x50, 0x81, 0xb0, 0x53, 0x87, 0xd0, 0x05, 0xeb, 0xc1, 0xf4, 0x40, 0x98, 0xa1, 0x09,
	0x3e, 0x9c, 0x74, 0x3f, 0x35, 0x60, 0xb7, 0xaa, 0xc0, 0xe6, 0xe2, 0xb5, 0x9d, 0xe2, 0x7e, 0x0a,
	0xbf, 0x37, 0xeb, 0xf8, 0x89, 0xa3, 0xa8, 0x94, 0x70, 0x7f, 0x63, 0x5e, 0xea, 0x52, 0x5f, 0xa3,
	0x17, 0x6f, 0x81, 0xf1, 0x50, 0xc1, 0x67, 0x3c, 0x44, 0xea, 0x44, 0xd4, 0x74, 0x93, 0x1a, 0x27,
	0x64, 0x1b, 0xcc, 0xe0, 0xa1, 0x72, 0x5b, 0x33, 0x78, 0x28, 0xe8, 0x13, 0xe5, 0xaf, 0x66, 0x70,
	0x52, 0xf8, 0x7b, 0xbf, 0xd9, 0xdf, 0xa1, 0xd9, 0xdf, 0x07, 0xcd, 0xfe, 0xbe, 0xb5, 0xd6, 0xdf,
	0x87, 0x2f, 0xf3, 0xf7, 0x9f, 0x19, 0xf0, 0xd6, 0x0a, 0x62, 0x9b, 0xb2, 0xdb, 0xfb, 0xd0, 0x4e,
	0x71, 0x3f, 0x65, 0xb7, 0xdd, 0x4b, 0x7e, 0x2f, 0x4e, 0xa3, 0x52, 0xc8, 0xfd, 0xad, 0xd9, 0xf8,
	0x2d, 0xf1, 0x1a, 0xcd, 0x87, 0x71, 0xc1, 0x62, 0xce, 0x32, 0xdd, 0x1f, 0x4a, 0x0a, 0x95, 0x0e,
	0xe8, 0x74, 0x16, 0xaa, 0x5c, 0x24, 0x09, 0x61, 0xc0, 0x47, 0x85, 0x41, 0x1f, 0x15, 0x06, 0xec,
	0x35, 0x1b, 0xb0, 0xdf, 0x6c, 0x40, 0x68, 0x36, 0xe0, 0x60, 0xad, 0x01, 0xb7, 0x5e, 0x66, 0xc0,
	0x9f, 0x1b, 0xf0, 0xf9, 0x06, 0xdc, 0x36, 0x67, 0x44, 0xcb, 0x5f, 0x46, 0x2b, 0x1f, 0x35, 0x0d,
	0xe7, 0x51, 0x14, 0x73, 0xff, 0x6c, 0xa9, 0xef, 0xbe, 0xc2, 0x04, 0x46, 0xc5, 0x04, 0x04, 0x5a,
	0xfe, 0x2c, 0xbc, 0xa3, 0xbe, 0x49, 0xc4, 0x18, 0xcd, 0x72, 0x7f, 0x72, 0x57, 0xf7, 0xd1, 0xf7,
	0x27, 0x77, 0x51, 0x2a, 0x38, 0x0c, 0x9e, 0xea, 0xc6, 0x0b, 0xc7, 0x08, 0x15, 0xfe, 0x47, 0x60,
	0x65, 0xef, 0xa5, 0x49, 0x34, 0x62, 0xe6, 0x05, 0xe1, 0x22, 0x57, 0xd6, 0x52, 0x14, 0xb6, 0x59,
	0xf9, 0xe2, 0xf1, 0x84, 0x71, 0x81, 0x62, 0x57, 0xb4, 0xbd, 0x15, 0x0e, 0xf9, 0x0a, 0x74, 0x72,
	0xee, 0x71, 0x96, 0x3b, 0xbd, 0xda, 0x27, 0xa1, 0xb8, 0xbd, 0xfc, 0x8b, 0x5d, 0x2e, 0xa3, 0x4a,
	0x8c, 0xbc, 0x03, 0xad, 0x19, 0x6e, 0xd5, 0x5f, 0x63, 0x10, 0x31, 0x4b, 0xde, 0x87, 0x1e, 0xc7,
	0xb5, 0x47, 0x93, 0xf5, 0xb5, 0xa6, 0x90, 0xd8, 0xfb, 0xa5, 0xa1, 0xea, 0xad, 0x38, 0x0a, 0xb1,
	0x88, 0x12, 0x5f, 0x41, 0x86, 0x43, 0xe1, 0x74, 0xb7, 0x15, 0x5e, 0x66, 0x70, 0x5b, 0x38, 0xf1,
	0x2c, 0x54, 0xd9, 0x1d, 0x87, 0x68, 0xdc, 0x64, 0xce, 0xce, 0x3c, 0x05, 0x97, 0x24, 0x70, 0xdd,
	0xb3, 0xdb, 0x0a, 0x2a, 0xf3, 0xd9, 0x6d, 0x61, 0x0d, 0x2f, 0xfe, 0x48, 0x57, 0x57, 0x1c, 0xeb,
	0xf4, 0xdf, 0x2d, 0xd3, 0xbf, 0x0d, 0x56, 0xc6, 0x4e, 0x05, 0x20, 0x26, 0xc5, 0xa1, 0x9b, 0xa9,
	0x74, 0xba, 0x29, 0x6f, 0x72, 0xa1, 0x2d, 0x94, 0x57, 0xfe, 0xb4, 0x55, 0x05, 0x9d, 0xca, 0x29,
	0xf7, 0x5f, 0x66, 0xc3, 0x83, 0x41, 0xe5, 0x00, 0xe3, 0x45, 0x07, 0x54, 0xb2, 0x85, 0xb9, 0x36,
	0x5b, 0x58, 0xf5, 0x6c, 0xb1, 0x0b, 0x1d, 0x16, 0xb3, 0xec, 0x6c, 0xa9, 0xeb, 0xa3, 0xa4, 0x74,
	0xc6, 0x50, 0xf5, 0x11, 0x33, 0xc6, 0x5d, 0x18, 0xfa, 0x49, 0xcc, 0xb3, 0xf0, 0xf1, 0x02, 0xb1,
	0xc8, 0x45, 0xba, 0x1f, 0xdc, 0x19, 0x95, 0x3d, 0x73, 0xfd, 0xd6, 0xfb, 0x07, 0x52, 0x9a, 0xd6,
	0x97, 0xed, 0xfd, 0xd8, 0x80, 0xae, 0x9a, 0x42, 0x47, 0x2d, 0xbf, 0x6b, 0x14, 0xa8, 0xd5, 0xcf,
	0xd3, 0xf2, 0x76, 0x66, 0xed, 0x76, 0x4d, 0x95, 0x5e, 0x7d, 0x94, 0xb6, 0x6a, 0x5f, 0xc7, 0x39,
	0x67, 0xe9, 0xb4, 0xd0, 0x43, 0x93, 0x98, 0xf8, 0x3f, 0x77, 0xe9, 0xc2, 0x9b, 0xb2, 0xf3, 0xbb,
	0xd5, 0x86, 0xc7, 0x59, 0x07, 0x8f, 0xec, 0x7b, 0x7e, 0x6a, 0x34, 0xbc, 0x04, 0xbd, 0x52, 0xda,
	0xbf, 0x01, 0x7d, 0x6f, 0x9e, 0x46, 0x21, 0x5f, 0x04, 0xfa, 0x31, 0xa0, 0x64, 0xd4, 0x9f, 0x23,
	0xdb, 0x72, 0xb6, 0x60, 0x08, 0x38, 0x2e, 0xdd, 0xe2, 0xb5, 0xc2, 0x71, 0xe9, 0x34, 0x09, 0xc7,
	0xdf, 0x8c, 0xd5, 0x17, 0xb0, 0x57, 0xc2, 0xa2, 0x74, 0x1b, 0xab, 0xe6, 0x36, 0x37, 0xa0, 0x2f,
	0x47, 0x98, 0x4b, 0xa5, 0xbf, 0x97, 0x8c, 0xc6, 0x0f, 0x5c, 0x15, 0x06, 0x9d, 0x32, 0x0c, 0x74,
	0x6e, 0xef, 0x56, 0x72, 0xbb, 0x0b, 0x56, 0xe6, 0x5d, 0x88, 0x6a, 0xd8, 0xd8, 0x20, 0x66, 0xde,
	0x05, 0x36, 0x88, 0xce, 0xeb, 0x01, 0xf8, 0x8b, 0x55, 0x80, 0xf5, 0x17, 0x5d, 0x13, 0xba, 0x7f,
	0x37, 0x8b, 0xb7, 0xc4, 0xc6, 0x12, 0xb5, 0x2e, 0xda, 0x6a, 0xb0, 0x59, 0xab, 0xb0, 0x55, 0x7a,
	0x0b, 0xb3, 0xe8, 0x2d, 0xd2, 0x24, 0x97, 0xf5, 0x4a, 0xbe, 0x3d, 0x09, 0x0a, 0xb5, 0xe4, 0x33,
	0xc6, 0x3d, 0xdd, 0x5b, 0x08, 0x42, 0xa7, 0xf5, 0x6e, 0x99, 0xd6, 0x77, 0xa1, 0x13, 0x84, 0x19,
	0xae, 0x97, 0xd9, 0x58, 0x51, 0xb8, 0x3e, 0x9f, 0x79, 0x29, 0x13, 0x65, 0xc8, 0xa4, 0x92, 0x20,
	0xb7, 0xa0, 0x35, 0x2d, 0x2b, 0xce, 0x4e, 0x89, 0x91, 0x7a, 0x6a, 0xa3, 0x62, 0xba, 0x28, 0x61,
	0x83, 0x17, 0x96, 0x30, 0x07, 0xba, 0x17, 0x2c, 0x3c, 0x9b, 0xa9, 0xe6, 0xc3, 0xa4, 0x9a, 0x2c,
	0x6b, 0xea, 0x61, 0xcc, 0x64, 0x6b, 0x69, 0xd2, 0x0a, 0xc7, 0x7d, 0x06, 0x3b, 0x0a, 0xdb, 0x4d,
	0xd9, 0x75, 0x0c, 0x5d, 0x5f, 0xee, 0xa8, 0x6c, 0xbb, 0xad, 0x6d, 0x2b, 0xb9, 0x54, 0x4f, 0xbb,
	0xbf, 0xb2, 0x6a, 0xef, 0xc2, 0x8d, 0xc6, 0x15, 0x0f, 0x31, 0xa6, 0xec, 0xd0, 0xd3, 0xb5, 0x11,
	0xa2, 0xea, 0x62, 0xab, 0xac, 0x8b, 0xfa, 0x7d, 0x4e, 0x45, 0xc5, 0xca, 0xfb, 0x5c, 0x67, 0xf5,
	0xa3, 0x0a, 0x6b, 0x68, 0xb7, 0xa8, 0xa1, 0x85, 0x71, 0x7a, 0x2f, 0x36, 0x8e, 0x03, 0xdd, 0xe9,
	0xd1, 0xe4, 0x61, 0xce, 0x02, 0xfd, 0xf9, 0xaa, 0x48, 0xf2, 0x0e, 0x0c, 0xcf, 0x92, 0x24, 0x88,
	0x59, 0x9e, 0x7f, 0x7c, 0x3a, 0x3d, 0x9a, 0xa8, 0x26, 0xb2, 0xce, 0x44, 0xe3, 0x66, 0xcc, 0x7f,
	0x81, 0x71, 0x71, 0x96, 0x8c, 0xa1, 0x23, 0xaa, 0xec, 0xfa, 0xc6, 0x52, 0xcd, 0x63, 0x27, 0xa3,
	0xb0, 0x5d, 0xff, 0x15, 0x51, 0x48, 0xa0, 0x74, 0xce, 0xbd, 0x8c, 0x9f, 0xf0, 0xa7, 0xce, 0xf6,
	0x9a, 0x1c, 0x50, 0x48, 0xb8, 0x9f, 0x19, 0x70, 0xad, 0x62, 0xac, 0x4d, 0x79, 0xcb, 0xfe, 0xa5,
	0x97, 0x43, 0x52, 0x5c, 0xc2, 0x6f, 0x78, 0x3a, 0xfc, 0x93, 0xa1, 0x7f, 0x3a, 0x10, 0x8f, 0xc0,
	0x59, 0x38, 0xf7, 0xb2, 0xa5, 0x4e, 0xb1, 0x8a, 0xac, 0xbe, 0x2f, 0x9b, 0xf5, 0xf7, 0x65, 0xdd,
	0xce, 0x5a, 0x95, 0x76, 0x96, 0x40, 0x2b, 0xcd, 0x92, 0xc7, 0xba, 0x79, 0xc5, 0x71, 0x43, 0x1f,
	0xa1, 0x5c, 0xac, 0x53, 0xba, 0x58, 0xf9, 0x56, 0xdd, 0xad, 0xbe, 0x55, 0x8b, 0x2f, 0x01, 0x79,
	0xf7, 0xb5, 0xa9, 0x55, 0x0b, 0xb8, 0xe7, 0x60, 0x4b, 0x6d, 0x36, 0x85, 0xe7, 0xad, 0xe2, 0x45,
	0x5b, 0xa2, 0xa9, 0xc5, 0xe4, 0x29, 0xfa, 0x81, 0xdb, 0xfd, 0x41, 0xf9, 0xa3, 0x0b, 0x7a, 0xe1,
	0x69, 0x96, 0xcc, 0x55, 0x93, 0xd6, 0xe0, 0x85, 0x38, 0x4b, 0x46, 0x60, 0xf2, 0x44, 0x9d, 0xdd,
	0xf0, 0x66, 0xca, 0x13, 0xc4, 0x43, 0x66, 0x1d, 0x1d, 0x9c, 0x92, 0x72, 0x3f, 0x01, 0xa2, 0xcf,
	0xda, 0x94, 0x96, 0xef, 0x41, 0x2f, 0x53, 0x5b, 0x2a, 0x3d, 0xaf, 0x14, 0x57, 0x92, 0x6c, 0x5a,
	0x08, 0x7c, 0xd7, 0xfe, 0xe3, 0xf3, 0x9b, 0xc6, 0x5f, 0x9f, 0xdf, 0x34, 0xfe, 0xf1, 0xfc, 0xa6,
	0xf1, 0x8b, 0x7f, 0xde, 0x7c, 0xe3, 0x71, 0x47, 0xfc, 0xba, 0xfa, 0xd5, 0xff, 0x06, 0x00, 0x00,
	0xff, 0xff, 0x61, 0x8f, 0x50, 0xab, 0x6c, 0x1d, 0x00, 0x00,
}
